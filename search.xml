<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>小王个人简历</title>
      <link href="/2023/05/19/profile/"/>
      <url>/2023/05/19/profile/</url>
      
        <content type="html"><![CDATA[<h2 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h2><style>.container {  overflow: hidden;}img {  float: right;  margin-left: 10px;  margin-right: 10px;  margin-top: 30px;}</style><div class="container">  <img src="https://note.youdao.com/yws/api/personal/file/WEB1bea44860148bf0a002470392a3449f7?method=download&shareKey=669d47fbbaf841f674b718d62fc35612" alt="图片描述" width='100'/>  <p><p>  <strong>就读院校</strong>：西安交通大学（本科）、国防科技大学（硕士）</p><p>  <strong>专业</strong>：计算机科学与技术</p><p>  <strong>出生年月</strong>：1999年8月 <strong>电话</strong>：182-2994-5747  <strong>邮箱</strong>：<a href="mailto:&#119;&#114;&#113;&#x32;&#x30;&#x32;&#49;&#64;&#x6e;&#117;&#100;&#x74;&#x2e;&#101;&#100;&#117;&#46;&#99;&#110;">&#119;&#114;&#113;&#x32;&#x30;&#x32;&#49;&#64;&#x6e;&#117;&#100;&#x74;&#x2e;&#101;&#100;&#117;&#46;&#99;&#110;</a></p><p>  <a href="https://archiodyssey.github.io/2023/05/19/profile_en/">View the profile in English</a></p>  </p></div><h2 id="研究方向"><a href="#研究方向" class="headerlink" title="研究方向"></a>研究方向</h2><ul><li>领域定制加速器</li><li>高性能网络与微体系结构</li><li>并行与分布式计算</li></ul><h2 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h2><p><strong>2021.09 ~ 至今:  国防科技大学  计算机科学与技术  学术硕士(非军籍)</strong></p><ul><li>一篇CCF-B类会议论文（第一作者），专利一项</li></ul><p><strong>2017.08 ~ 2021.07:  西安交通大学  计算机科学与技术  工学学士</strong></p><ul><li>西安交通大学校级奖学金、西安交通大学优秀学生</li><li>2019年中国国际飞行器设计挑战赛全国二等奖</li><li>六级英语593分</li><li>部分课程设计：<ul><li>5级流水线微处理器设计（Verilog实现）、Y86-64微处理器实验、Shell程序、malloc内存分配器、文件系统实验、可靠数据传输协议、FTP文件传输、MPI并行矩阵乘法等</li></ul></li><li>专业能力：<ul><li>C&#x2F;C++、汇编（x86-64和ARM 9）、Python，Verilog、VHDL、Java、SQL、Linux系统、并行程序设计（MPI和OpenMP）、gdb调试和反汇编</li></ul></li></ul><h2 id="论文发表"><a href="#论文发表" class="headerlink" title="论文发表"></a>论文发表</h2><ul><li><p><em><strong>Ruiqi Wang</strong></em>, Dezun Dong, Fei Lei, Ke Wu, Junchao Ma, and Kai Lu. 2023.<br><a href="https://doi.org/10.1145/3577193.3593711">Roar: A Router Microarchitecture for In-network Allreduce.</a> In International<br>Conference on Supercomputing (<strong>ICS’23</strong>, CCF-B类会议，高性能计算顶会)</p></li><li><p>Aoxiang Feng, Dezun Dong, Fei Lei, Junchao Ma, Enda Yu and <em><strong>Ruiqi Wang</strong></em>. 2022. <a href="https://doi-org-s.libyc.nudt.edu.cn/10.1016/j.comcom.2022.11.004">In-network aggregation for data center networks: A survey.</a> In Computer Communications. (CCF-C类期刊)</p></li></ul><h2 id="项目和科研经历"><a href="#项目和科研经历" class="headerlink" title="项目和科研经历"></a>项目和科研经历</h2><h3 id="1、中国国际飞行器设计挑战赛——固定翼对地侦察与打击无人机"><a href="#1、中国国际飞行器设计挑战赛——固定翼对地侦察与打击无人机" class="headerlink" title="1、中国国际飞行器设计挑战赛——固定翼对地侦察与打击无人机"></a>1、中国国际飞行器设计挑战赛——固定翼对地侦察与打击无人机</h3><ul><li><p>总结：设计了一个自动巡航的侦察打击无人机</p></li><li><div class="container"><img src="https://pica.zhimg.com/v2-0cbb8d7df835d25ebc9657d18e3b65b4_r.jpg?source=c8b7c179" alt="图片描述" width='250'/><p><p>担任<strong>队长</strong>，并负责<strong>飞控系统的开发</strong>。飞机设计、制作、飞控功能均为团队自行完成。所设计的无人机能沿航线自动飞行，完成侦察和打击的任务。2019年10月获得全国二等奖。所在社团曾多次被西安交通大学和陕西省报道。2019年末，<strong>社团登上央视CCTV13新闻频道</strong>。</p></p></div></li><li><p>创新点：</p><ul><li>1、根据控制台输入的GPS坐标精准投弹，相机自动对准目标；</li><li>2、改进制导方式，飞机在高速飞行时能压准航线，并且能灵活调整方向；</li><li>3、开发图形化界面，往窗口输入坐标和点击按钮即可完成任务。</li><li>4、机翼和机身可折叠。</li></ul></li></ul><h3 id="2、硕士课题：并行和分布式应用的在网计算加速"><a href="#2、硕士课题：并行和分布式应用的在网计算加速" class="headerlink" title="2、硕士课题：并行和分布式应用的在网计算加速"></a>2、硕士课题：并行和分布式应用的在网计算加速</h3><ul><li><p>总结：设计了一个加速Allreduce操作的路由器微体系结构 (<em><strong>Roar</strong></em>: A <u><strong>Ro</strong></u>uter Microarchitecture for In-network <u><strong>A</strong></u>ll<u><strong>r</strong></u>educe)</p></li><li><p>关键词：在网计算、Allreduce、路由器、RDMA协议</p></li><li><p>并行计算和分布式深度学习有大量时间消耗在Allreduce操作上（收集所有主机的数据，再将聚合的结果广播给每个主机）。在网计算将Allreduce卸载到网络设备中完成，可以将性能提升至少2倍，并提高整个系统效率。该课题在标准路由器中设计了一个加速器支持Allreduce的在网计算加速，并且专门为RDMA网络定制。只有需要聚合的数据包才被加速器截获，聚合后，结果发送回路由器的输入，并路由到下一跳。该工作已发表在<strong>ICS’23</strong>会议上(<strong>ICS</strong>: International Conference on Supercomputing, 高性能计算三大顶会之一)<br><img src="https://note.youdao.com/yws/api/personal/file/WEBb34459007d69857ab4c7c5723ca8ee63?method=download&shareKey=18cfea4a59b4a56b1fde1d91ee2dda5d" alt="Roar架构示意图"></p></li><li><p>创新点</p><ul><li>新的路由器微体系结构，RDMA网卡被改装成加速器集成在路由器上。加速器为路由器的拓展模块，不影响路由器常规功能。</li><li>该加速器专门为RDMA网络定制，可实现高吞吐率。</li><li>利用一系列优化策略，解决了在网计算的几个共同挑战：高吞吐率、任意长度数据的在网聚合、结果的可重复性，并在性能和代价上取得平衡。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Profile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Profile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wang&#39;s Personal Resume</title>
      <link href="/2023/05/19/profile_en/"/>
      <url>/2023/05/19/profile_en/</url>
      
        <content type="html"><![CDATA[<h2 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information"></a>Basic Information</h2><style>.container {  overflow: hidden;}img {  float: right;  margin-left: 10px;  margin-right: 10px;  margin-top: 30px;}</style><div class="container">  <img src="https://note.youdao.com/yws/api/personal/file/WEB1bea44860148bf0a002470392a3449f7?method=download&shareKey=669d47fbbaf841f674b718d62fc35612" alt="图片描述" width='100'/>  <p><p>  <strong>Education backgorund</strong>：</p><ul><li>Xi’an Jiao Tong University (Bachelor)</li><li>National University of Defense Technology (Master)</li></ul><p>  <strong>Major</strong>: Computer science and technology </p><p>  <strong>Birthday</strong>：August, 1999  <strong>Telephone</strong>：182-2994-5747  <strong>Email</strong>：<a href="mailto:&#x77;&#x72;&#x71;&#x32;&#48;&#x32;&#49;&#64;&#x6e;&#x75;&#100;&#x74;&#x2e;&#101;&#x64;&#117;&#46;&#99;&#x6e;">&#x77;&#x72;&#x71;&#x32;&#48;&#x32;&#49;&#64;&#x6e;&#x75;&#100;&#x74;&#x2e;&#101;&#x64;&#117;&#46;&#99;&#x6e;</a></p><p>  <a href="https://archiodyssey.github.io/2023/05/19/profile/">中文版简历</a></p>  </p></div><h2 id="Research-Areas"><a href="#Research-Areas" class="headerlink" title="Research Areas"></a>Research Areas</h2><ul><li>Domain-specific Accelerators</li><li>High-performance Networks and Microarchitecture</li><li>Parallel and Distributed Computing</li></ul><h2 id="Educational-Experience"><a href="#Educational-Experience" class="headerlink" title="Educational Experience"></a>Educational Experience</h2><p><strong>2021.9 ~ Present: National University of Defense Technology, Computer Science and Technology, Master Student</strong></p><ul><li>One conference paper on <strong>ICS’23</strong> (first author), one patent.</li></ul><p><strong>2017.08 ~ 2021.07: Xi’an Jiaotong University, Computer Science and Technology, Bachelor Student</strong></p><ul><li>Xi’an Jiaotong University Scholarship, Outstanding Student of Xi’an Jiaotong University</li><li>National Second Prize in the 2019 Chinese Aircraft Design Challenge</li><li>CET-6 (College English Test band 6) score of 593</li><li>Course Projects: <ul><li>A pipelined microprocessor (Verilog implementation), Y86-64 microprocessor experiment, Shell program, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.014ex;" xmlns="http://www.w3.org/2000/svg" width="7.127ex" height="1.396ex" role="img" focusable="false" viewBox="0 -611 3150 617" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-M-1D696" d="M133 76Q156 74 164 67T172 38Q172 9 151 1H11Q-12 8 -12 38Q-12 61 5 73Q10 75 28 76H45V355H28Q10 356 5 358Q-12 370 -12 393Q-12 419 11 431H52H70Q91 431 100 427T116 405Q163 436 200 436Q255 436 281 390L285 394Q289 398 292 400T301 407T314 415T329 423T346 429T366 434T389 436H392Q425 436 448 411Q469 390 474 360T480 268V232V203V76H497Q520 74 528 67T536 38Q536 9 515 1H396Q374 9 374 32V38Q374 73 402 76H409V191V242Q409 317 404 339T375 361Q343 361 323 332T299 264Q298 258 298 165V76H315Q338 74 346 67T354 38Q354 9 333 1H214Q192 9 192 32V38Q192 73 220 76H227V191V242Q227 317 222 339T193 361Q161 361 141 332T117 264Q116 258 116 165V76H133Z"></path><path id="MJX-2-TEX-M-1D68A" d="M126 306Q105 306 90 321T74 359Q74 439 211 439Q268 439 276 438Q343 426 383 390T430 306Q431 301 431 190V81Q446 79 465 78T492 76T509 72T521 60T524 38Q524 11 506 3Q502 1 466 1Q426 1 406 5T379 14T355 36L345 30Q284 -6 205 -6Q135 -6 92 39T48 141Q48 182 79 212T158 256T252 278T342 285H347V290Q347 315 325 335T267 362Q258 363 224 363Q189 363 185 362H179L178 358Q178 353 178 352T176 345T174 337T170 330T165 322T158 316T150 311T139 308T126 306ZM132 140Q132 115 157 93T224 70Q269 70 302 87T344 133Q346 139 347 175V211H339Q256 209 194 190T132 140Z"></path><path id="MJX-2-TEX-M-1D695" d="M51 573Q51 602 73 610H76Q79 610 84 610T97 610T113 610T133 611T155 611T179 611H282Q301 598 304 586V76H452Q466 67 470 60T474 38Q474 10 452 1H73Q51 9 51 32V38Q51 54 54 60T73 76H220V535H146L73 536Q51 545 51 567V573Z"></path><path id="MJX-2-TEX-M-1D698" d="M52 216Q52 318 118 379T261 440Q343 440 407 378T472 216Q472 121 410 58T262 -6Q176 -6 114 58T52 216ZM388 225Q388 281 351 322T261 364Q213 364 175 325T136 225Q136 158 174 114T262 70T350 114T388 225Z"></path><path id="MJX-2-TEX-M-1D68C" d="M291 -6Q196 -6 131 60T66 216Q66 296 119 361Q154 403 200 421T273 439Q275 440 293 440H313Q400 440 433 409Q454 388 454 359Q454 335 439 321T402 306Q380 306 365 321T350 357V362L340 363Q339 363 326 363T303 364Q280 364 266 362Q217 352 184 313T151 215Q151 153 199 112T313 70Q341 70 357 85T381 118T394 140Q402 146 424 146Q443 146 447 144Q466 137 466 117Q466 106 457 88T429 47T374 10T291 -6Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><use data-c="1D696" xlink:href="#MJX-2-TEX-M-1D696"></use><use data-c="1D68A" xlink:href="#MJX-2-TEX-M-1D68A" transform="translate(525,0)"></use><use data-c="1D695" xlink:href="#MJX-2-TEX-M-1D695" transform="translate(1050,0)"></use><use data-c="1D695" xlink:href="#MJX-2-TEX-M-1D695" transform="translate(1575,0)"></use><use data-c="1D698" xlink:href="#MJX-2-TEX-M-1D698" transform="translate(2100,0)"></use><use data-c="1D68C" xlink:href="#MJX-2-TEX-M-1D68C" transform="translate(2625,0)"></use></g></g></g></svg></mjx-container> memory allocator, File system experiment, Reliable data transmission protocol, FTP file transfer, MPI parallel matrix multiplication</li></ul></li><li>Skills:<ul><li>Proficiency in C&#x2F;C++, Assembly (x86-64 and ARM9), Python, Verilog, VHDL, Java, SQL, Linux system, parallel programming (MPI and OpenMP), gdb debugging and disassembly.</li></ul></li></ul><h2 id="Paper-Publications"><a href="#Paper-Publications" class="headerlink" title="Paper Publications"></a>Paper Publications</h2><ul><li><p><em><strong>Ruiqi Wang</strong></em>, Dezun Dong, Fei Lei, Ke Wu, Junchao Ma, and Kai Lu. 2023.<br><a href="https://doi.org/10.1145/3577193.3593711">Roar: A Router Microarchitecture for In-network Allreduce.</a> In International<br>Conference on Supercomputing (<strong>ICS’23</strong>).</p></li><li><p>Aoxiang Feng, Dezun Dong, Fei Lei, Junchao Ma, Enda Yu and <em><strong>Ruiqi Wang</strong></em>. 2022. <a href="https://doi-org-s.libyc.nudt.edu.cn/10.1016/j.comcom.2022.11.004">In-network aggregation for data center networks: A survey.</a> In Computer Communications.</p></li></ul><h2 id="Project-and-Research-Experience"><a href="#Project-and-Research-Experience" class="headerlink" title="Project and Research Experience"></a>Project and Research Experience</h2><h3 id="1-Fixed-wing-Reconnaissance-and-Strike-UAV-in-2019-Chinese-Aircraft-Design-Challenge"><a href="#1-Fixed-wing-Reconnaissance-and-Strike-UAV-in-2019-Chinese-Aircraft-Design-Challenge" class="headerlink" title="1. Fixed-wing Reconnaissance and Strike UAV, in 2019 Chinese Aircraft Design Challenge."></a>1. Fixed-wing Reconnaissance and Strike UAV, in 2019 Chinese Aircraft Design Challenge.</h3><ul><li><p>Summary: Designing an automatic cruising reconnaissance and strike unmanned aerial vehicle (UAV).</p></li><li><div class="container"><img src="https://pica.zhimg.com/v2-0cbb8d7df835d25ebc9657d18e3b65b4_r.jpg?source=c8b7c179" alt="Aircraft" width='250'/><p>I served as the **captain** and was responsible for the development of the **flight control system**. The aircraft design, manufacturing, and flight control functions were all completed independently by the team. The drone can automatically fly along the route to complete reconnaissance and strike missions. In October 2019, we won the second prize in the national competition. The club has been reported by Xi'an Jiaotong University and Shanxi Province many times. At the end of 2019, our club was featured on the **China Central Television News Channel** (CCTV13).</p></div></li><li><p>Innovation Highlights:</p><ul><li><ol><li>Precise bombing based on GPS coordinates.</li></ol></li><li><ol start="2"><li>Improved flight control system that maintains stable flight path at high speeds and flexible direction adjustment.</li></ol></li><li><ol start="3"><li>A GUI that allows users to input coordinates and execute the mission with the click of a button.</li></ol></li><li><ol start="4"><li>Foldable wings and fuselage.</li></ol></li></ul></li></ul><h3 id="2-Master’s-Thesis-In-Network-Computing-Acceleration-for-Parallel-and-Distributed-Applications"><a href="#2-Master’s-Thesis-In-Network-Computing-Acceleration-for-Parallel-and-Distributed-Applications" class="headerlink" title="2. Master’s Thesis: In-Network Computing Acceleration for Parallel and Distributed Applications"></a>2. Master’s Thesis: In-Network Computing Acceleration for Parallel and Distributed Applications</h3><ul><li><p>Summary: Designing <em><strong>Roar</strong></em> (A <u><strong>Ro</strong></u>uter Microarchitecture for In-network <u><strong>A</strong></u>ll<u><strong>r</strong></u>educe).</p></li><li><p>Keywords: In-network Computing, Allreduce, Router, RDMA.</p></li><li><p>The <em>allreduce</em> operation collects data from all hosts and then broadcasts the aggregated results back to them. In-network computing can offload <em>allreduce</em> into network devices, which can improve performance by at least 2x. In this thesis, we introduce a groundbreaking solution named <strong>Roar</strong>, which is tailored for RDMA networks. Only packets requiring aggregation are intercepted by <strong>Roar</strong>. Once aggregated, the results are sent back to the router input units and routed to the next hop. This work has been published at the 2023 International Conference on Supercomputing (<strong>ICS’23</strong>).<br><img src="https://note.youdao.com/yws/api/personal/file/WEBb34459007d69857ab4c7c5723ca8ee63?method=download&shareKey=18cfea4a59b4a56b1fde1d91ee2dda5d" alt="Roar&#39;s Architecture"></p></li><li><p>Innovation Highlights:</p><ul><li>A new router microarchitecture that includes an integrated accelerator. This accelerator is built on the foundation of an RDMA NIC. As an extension to router, <strong>Roar</strong> does not affect its regular functions.</li><li><strong>Roar</strong> is tailored for RDMA networks and achieves high throughput.</li><li>A series of optimization to address several challenges in in-network allreduce, including high throughput, large message aggregation, result reproducibility, and balancing performance and cost.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Profile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Profile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件系统概念和Ext2文件系统</title>
      <link href="/2022/05/18/OS_FileSystem/"/>
      <url>/2022/05/18/OS_FileSystem/</url>
      
        <content type="html"><![CDATA[<h1 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h1><p>我在本科第一次学习“文件系统”时，觉得这一章的很多概念仿佛如空中楼阁，因为“文件系统”太抽象了，后来才慢慢加深理解，其实文件系统就是磁盘管理，也可以说文件系统是物理设备的高级抽象。硬盘（低速设备）读写单位是扇区，通常为512 Bytes，而文件系统的读写单位是块（若干个扇区组成，为了避免频繁访问磁盘，一次读入多个块）。为了管理这些块，需要各种数据结构。</p><h2 id="inode和文件控制块FCB"><a href="#inode和文件控制块FCB" class="headerlink" title="inode和文件控制块FCB"></a>inode和文件控制块FCB</h2><p>一个文件被拆分成多个块来存储，因此需要一种文件组织方式。以Windows的FAT32为例，FAT是文件分配表(File Allocation Table)，所有的块被用链式结构来组织，在每一块的最后记录下一块的地址，这样文件不需要连续存储，节省了磁盘空间。FAT文件系统为每个文件都分配了一个FAT表，用单独的链式结构来存储、跟踪文件的所有块。FAT文件系统的缺点是文件查找效率地下，为了定位到最后一个数据块，需要遍历前面的所有数据块，且每访问一个块就涉及一次磁盘寻道，使得本就低速的磁盘访问更加频繁，也许微软受不了FAT32文件系统，后来推出了NTFS文件系统(下图来自《操作系统概念》)。</p><div style = "align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB200ceca287a455a1754af8fc6e802128?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="40%" height="40%"/>  <p>Unix的文件系统比较先进，采用索引结构来组织文件块，文件块依然可以零散地分布在磁盘中，但Unix文件系统为每个文件的所有块都建立了一个索引表，索引表就是块地址数组，数组元素就是块的地址，访问任意一个块只需要从索引表获得块地址就可以了，速度大大提升。包含此索引表的索引结构就是index node，简称inode(i节点)。任何一个文件都有一个inode，inode记录了文件的所有信息，包括一个索引表，记录文件所有块的块地址。索引结构的缺点是索引结构本身要占一定的存储空间，文件越大，块越多，索引表越大，因此Unix采取了一个折中的方法，采用多级索引结构：inode的索引表一共15个索引项，如果文件块小于12块，那么将这12块的块地址直接存储在前12个索引项中，这前面12个索引可以直接获得块地址，如果文件大于12块，就用第13个索引（一级索引指针）指向一个新的块，新的一块存储256个块地址（一个块1024字节，一个块地址4字节，所以可以存储256个块地址），因此一级索引结构可以存储12+256&#x3D;268个块。如果文件大于268个块，就建立二级索引指针，因此inode索引表的第14个索引是二级索引指针，，第15个是三级索引指针，这样可以管理非常大的文件（文件最多$12+256+256\times{256}+256\times{256}\times{256}块\approx{16.06G}$，如果一个块1024个字节）。</p><div style = "align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB5c6be0c67c8d7e412bb46a0fc7dfc4b2?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="50%" height="50%"/>  <p>只要用于控制和管理文件相关信息的数据结构都叫文件控制块FCB(File Control Block)，因此inode也是FCB的一种。并且inode的数量等于文件数量，为了方便管理，分区中所有文件的inode都用一个大表格(inode_table)来维护，用单独的几个磁盘块来存储这个表格，再结合inode位图（单独的一块）。表格就是一个数组，数组中的元素就是inode地址，数组的下标就是inode的编号。可以根据inode编号来查询inode地址。Linux中的inode的定义如下（少了3个字段，但是不重要，没贴出来，来自《深入理解Linx内核》）：</p><div style = "align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB59ac0acfacd302c44a1c25b94075ea37?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/>  <h2 id="目录项与目录"><a href="#目录项与目录" class="headerlink" title="目录项与目录"></a>目录项与目录</h2><p>在Unix的inode中，缺少了一个对用户来说至关重要的属性：文件名。用户给出文件名来访问文件，而文件系统通过inode来定位数据块（文件名对文件系统来说不重要，有了inode即可）。因此目录的作用就是将文件名和inode绑定。用户给出文件名，文件在目录项中找到文件名对应的inode，然后再找到数据块。<br>在Linux中，目录和文件都用inode来表示，因此目录也是一种文件。inode同时指向目录和普通文件，磁盘文件系统中没有一种叫做目录的数据结构，磁盘上有的只是inode，inode指向文件实体的数据块，而不关心数据块具体的内容，因此目录和普通文件本质的区别就是“数据块上记录的内容”不同。例如，一个.txt文本文件的数据块记录的是文本文件的ASCII码，而一个目录文件的数据块，记录的内容是目录下包含的所有目录项，如下所示：</p><div style = "align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB3edb3a5062775e84e27a1b3baf7214d4?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/>  <p>其中’.’表示当前目录，’..’表示上一级目录，每一个目录项的字段如下所示：</p><div style = "align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB8ccdb56ae2d2ddd63d7a13a576d23bb1?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/> <p>目录项长度通常为4的倍数，不足4的倍数会在文件名末尾补上’\0’。可以看到，目录项包含文件对应的inode索引，因此获得这个索引之后，就可以根据该索引值计算出inode地址，然后就可以得到文件的inode了。这一个inode指向的文件也可能是目录文件，因此数据块中包含目录项，这样就可以根据多级目录来查询了。另外，不管是普通文件还是目录文件（这里将目录称之为“目录文件”），总会位于一个目录下，所有普通文件和目录都位于根目录’&#x2F;‘下，根目录是所有目录的父目录。<br>我本科学到这里的时候被绕晕了：要想找到数据块，必须找到文件的inode，而要找到文件的inode，又必须要知道目录项（目录项包含inode索引），而要找到目录项又必须先找到数据块（目录项本身又是目录文件数据块里面的内容）……寻找过程似乎是个死循环。这种看似死循环的过程，原因无外乎就是上层目录是无休止的，因此有个固定的目录就可以了，答案就是根目录’&#x2F;‘！每个分区都有自己的根目录，根目录是所有目录的父目录，在创建文件分区的时候就已经在一个固定死的位置写好了根目录的inode，查找文件时时都首先根据根目录inode获得根目录数据块，然后再查找这个数据块里面的目录项，最后递归查找，找到任意子目录的文件。因此查找&#x2F;home&#x2F;hello.txt文件的过程是：</p><ul><li>1、文件系统找到根目录’&#x2F;‘的inode</li><li>2、由根目录的inode找到根目录的数据块</li><li>3、根目录数据块中有home目录项，并由home目录项找到home这个目录文件的inode</li><li>5、由home目录文件的inode找到home目录的数据块</li><li>6、home目录数据块有hello.txt目录项，并由该目录项找到hollo.txt这个文件的inode</li><li>7、由hello.txt文件的inode找到对应的数据块，数据块存储着字符串的ASCII码值。</li></ul><h2 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h2><p>Ext2文件系统在磁盘上的布局如下图所示：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB8773c112d52de95d6691bdec4e7ea012?method=download&shareKey=69113f8f61e335d1864757cf6d288929"><br>Ext2文件系统将若干个块分成一个组，一个分区可能有多个块组。</p><ul><li><p>在整个磁盘中，最开始一个块是引导块，包含引导操作系统的相关信息，MBR(Master Boot Record和Loader程序就在这个块中)。如果该磁盘不包含操作系统，则该块内容为空。NTFS文件系统称该之为分区引导扇区。</p></li><li><p>每个块组的第一块是超级块，是在为分区创建文件系统时创建的，超级块包含总的inode数量、块的数量、每块的大小（字节）、每组的块数等等这些重要信息，详细字段如下所示：</p><div style = "align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEBb353acd38c3d124728dfb939d9eb1472?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/> </li><li><p>组描述符紧跟着超级块，记录着数据块位图从几号块开始、inode位图从几号块开始、inode节点从几号块开始等等信息，具体字段如下：</p><div style = "align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB4f0be2bb01668eba716ad737927f1217?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/></li><li><p>之后是数据块位图和inode位图，记录那些块被（数据块或者inode）使用过了，1比特表示对应的块被使用过了。</p></li><li><p>索引节点块存储所有inode。</p></li><li><p>后面的所有块均为存储数据的数据块（存储目录文件、普通文件）</p></li></ul><h2 id="Ext2文件系统实例"><a href="#Ext2文件系统实例" class="headerlink" title="Ext2文件系统实例"></a>Ext2文件系统实例</h2><p>现有一个磁盘had.raw，根目录的内容如下，一共4个文件（包括目录）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">..</span><br><span class="line">lost+found</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure><p>利用hexdump命令查看磁盘内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C rootfs/hda.raw | less</span><br></pre></td></tr></table></figure><p>磁盘内容如下，可以根据各个块的字段来查看意义：</p><h3 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br><span class="line"><span class="comment">//以上为引导块（0号块），接下来为超级块（1号块）</span></span><br><span class="line"><span class="number">00000400</span>  <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">08</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">66</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> cd <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>  |........f.......|</span><br><span class="line">          ^_________^ ^_________^</span><br><span class="line">        s_inodes_count s_blocks_count</span><br><span class="line"><span class="number">00000410</span>  f4 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">                                   ^_________^</span><br><span class="line">                                   s_log_block_size</span><br><span class="line"><span class="number">00000420</span>  <span class="number">00</span> <span class="number">20</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">20</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">43</span> <span class="number">54</span> <span class="number">9</span>e <span class="number">5</span>e  |. ... ......CT.^|</span><br><span class="line">          ^_________^              ^_________^</span><br><span class="line">          s_blocks_per_group       s_inodes_per_group</span><br><span class="line"><span class="number">00000430</span>  c8 <span class="number">56</span> <span class="number">9</span>e <span class="number">5</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">15</span> <span class="number">00</span>  <span class="number">53</span> ef <span class="number">01</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |.V.^....S.......|</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">字段</th><th align="center">值</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">s_inodes_count</td><td align="center">0x0100</td><td align="center">总共包含0x0100个inode</td></tr><tr><td align="center">s_blocks_count</td><td align="center">0x0800</td><td align="center">总共包含0x0800块</td></tr><tr><td align="center">s_log_block_size</td><td align="center">0x0000</td><td align="center">块大小为$1024\times{2^0}$，即1024B</td></tr><tr><td align="center">s_blocks_per_group</td><td align="center">0x2000</td><td align="center">每组包含0x2000块</td></tr><tr><td align="center">s_inodes_per_group</td><td align="center">0x0100</td><td align="center">每组包含0x0100(256)个inode，占$\frac{256}{8}&#x3D;32$个块</td></tr></tbody></table><p>其中每个inode占128字节，因此一个块包含$\frac{1024}{128}&#x3D;8$个inode。</p><h3 id="组描述符"><a href="#组描述符" class="headerlink" title="组描述符"></a>组描述符</h3><p>组描述符紧跟着超级块</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为组描述符（2号块）</span></span><br><span class="line"><span class="number">00000800</span>  <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> cd <span class="number">07</span> f4 <span class="number">00</span>  |................|</span><br><span class="line">          ^_________^ ^_________^  ^_________^</span><br><span class="line">     bg_clock_bitmap bg_inode_bitmap bg_inode_table</span><br><span class="line"><span class="number">00000810</span>  <span class="number">02</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line"><span class="number">00000820</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">字段</th><th align="center">值</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">bg_clock_bitmap</td><td align="center">0x03</td><td align="center">数据块位图区从3号块开始</td></tr><tr><td align="center">bg_inode_bitmap</td><td align="center">0x04</td><td align="center">inode位图区从4号块开始</td></tr><tr><td align="center">bg_inode_table</td><td align="center">0x05</td><td align="center">inode区从5号块开始</td></tr></tbody></table><h3 id="数据区位图和inode位图-bitmap"><a href="#数据区位图和inode位图-bitmap" class="headerlink" title="数据区位图和inode位图(bitmap)"></a>数据区位图和inode位图(bitmap)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为数据块位图区（3号块）</span></span><br><span class="line"><span class="number">00000</span>c00  ff ff ff ff ff ff <span class="number">01</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line"><span class="number">00000</span>c10  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br><span class="line"><span class="comment">//以下为i节点位图区（4号块）</span></span><br><span class="line"><span class="number">00001000</span>  ff <span class="number">0f</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line"><span class="number">00001010</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line"><span class="number">00001020</span>  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">***</span><br></pre></td></tr></table></figure><h3 id="inode区"><a href="#inode区" class="headerlink" title="inode区"></a>inode区</h3><p>inode区从5号块开始，因此起始地址应该是0x400$\times{5}&#x3D;$0x1400，查看此处数据。另外根目录的inode是定死的，位于inode区的第2个，地址就是0x1400+128$\times$2&#x3D;0x1480（inode区的第一个inode没有意义）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为inode区（5号块）</span></span><br><span class="line"><span class="number">00001400</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br><span class="line"><span class="comment">//以下为2号i节点（i节点从1开始编号），即根目录的i节点</span></span><br><span class="line"><span class="number">00001480</span>  ed <span class="number">41</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">49</span> <span class="number">4</span>d <span class="number">9</span>e <span class="number">5</span>e <span class="number">46</span> <span class="number">4</span>a <span class="number">9</span>e <span class="number">5</span>e  |.A......IM.^FJ.^|</span><br><span class="line">                      ^_________^</span><br><span class="line">                      <span class="built_in">i_size</span>(bytes)</span><br><span class="line"><span class="number">00001490</span>  <span class="number">46</span> <span class="number">4</span>a <span class="number">9</span>e <span class="number">5</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">03</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |FJ.^............|</span><br><span class="line">                                               ^_________^</span><br><span class="line">                                                i_blocks</span><br><span class="line"><span class="number">000014</span>a0  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">25</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |........%.......|</span><br><span class="line">                                   ^_________^</span><br><span class="line">                                    i_block</span><br><span class="line"><span class="number">000014b</span>0  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">字段</th><th align="center">值</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">i_size</td><td align="center">0x0400</td><td align="center">文件大小0x400B&#x3D;1KB</td></tr><tr><td align="center">i_blocks</td><td align="center">0x0002</td><td align="center">文件数据块数为2</td></tr><tr><td align="center">i_block</td><td align="center">0x0025</td><td align="center">第一个数据块的块号为37，偏移是0x400$\times$37&#x3D;0x9400</td></tr></tbody></table><h3 id="根目录数据块"><a href="#根目录数据块" class="headerlink" title="根目录数据块"></a>根目录数据块</h3><p>在地址0x9400处查看根目录数据块中的内容，其中记录着目录项：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为根目录的第一个数据块</span></span><br><span class="line"><span class="number">00009400</span>  <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>c <span class="number">00</span> <span class="number">01</span> <span class="number">02</span>  <span class="number">2</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">          ^_________^ ^___^ ^^ ^^  ^_________^ ^_________^</span><br><span class="line">          inode       rec_len      name         inode</span><br><span class="line">                            ^name_len </span><br><span class="line">                               ^file_type      ^第<span class="number">2</span>个目录项</span><br><span class="line"><span class="number">00009410</span>  <span class="number">0</span>c <span class="number">00</span> <span class="number">02</span> <span class="number">02</span> <span class="number">2</span>e <span class="number">2</span>e <span class="number">00</span> <span class="number">00</span>  <span class="number">0b</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">14</span> <span class="number">00</span> <span class="number">0</span>a <span class="number">02</span>  |................|</span><br><span class="line">          ^___^ ^^ ^^ ^_________^  ^_________^ ^___^ ^^ ^^</span><br><span class="line">                                   ^第<span class="number">3</span>个目录项</span><br><span class="line"><span class="number">00009420</span>  <span class="number">6</span>c <span class="number">6f</span> <span class="number">73</span> <span class="number">74</span> <span class="number">2b</span> <span class="number">66</span> <span class="number">6f</span> <span class="number">75</span>  <span class="number">6</span>e <span class="number">64</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>c <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |lost+found......|</span><br><span class="line">          ^__________________________________^ ^_________^</span><br><span class="line">          ^文件名lost+found，末尾用\<span class="number">0</span>补充        ^第<span class="number">4</span>个目录项</span><br><span class="line"><span class="number">00009430</span>  d4 <span class="number">03</span> <span class="number">09</span> <span class="number">01</span> <span class="number">68</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c  <span class="number">6f</span> <span class="number">2</span>e <span class="number">74</span> <span class="number">78</span> <span class="number">74</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |....hello.txt...|</span><br><span class="line">          ^___^ ^^ ^^ ^__________________________________^</span><br><span class="line">                      ^名字hello.txt</span><br><span class="line"><span class="number">00009440</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">inode号</th><th align="center">目录项长度</th><th align="center">文件名长度</th><th align="center">文件类型</th><th align="center">文件名</th></tr></thead><tbody><tr><td align="center">0x02</td><td align="center">0x0c: 12 Bytes</td><td align="center">0x1</td><td align="center">目录</td><td align="center">.</td></tr><tr><td align="center">0x02</td><td align="center">0x0c: 12 Bytes</td><td align="center">0x1</td><td align="center">目录</td><td align="center">..</td></tr><tr><td align="center">0x0b</td><td align="center">0x14: 20 Bytes</td><td align="center">0x0a: 10</td><td align="center">目录</td><td align="center">lost+found</td></tr><tr><td align="center">0x0c</td><td align="center">0x3d4 Bytes</td><td align="center">0x09</td><td align="center">普通文件</td><td align="center">hello.txt</td></tr></tbody></table><p>这是根目录下的目录项，注意到第1个和第2个目录项的inode号都是0x02号inode，指向根目录自己（打开当前目录和打开上一级目录都是指向自己）。此外hello.txt的inode号为0x0c，因此hello.txt的inode的地址为0x1400+0x80$\times$(0x0c-1)&#x3D;0x1980，在此处查看hello.txt的inode信息。</p><h3 id="hello-txt的inode"><a href="#hello-txt的inode" class="headerlink" title="hello.txt的inode"></a>hello.txt的inode</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为hello.txt的i节点（12号）</span></span><br><span class="line"><span class="number">00001980</span>  a4 <span class="number">81</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">56</span> <span class="number">4</span>a <span class="number">9</span>e <span class="number">5</span>e <span class="number">46</span> <span class="number">4</span>a <span class="number">9</span>e <span class="number">5</span>e  |........VJ.^FJ.^|</span><br><span class="line"><span class="number">00001990</span>  <span class="number">46</span> <span class="number">4</span>a <span class="number">9</span>e <span class="number">5</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |FJ.^............|</span><br><span class="line"><span class="number">000019</span>a0  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">01</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">                                   ^_________^</span><br><span class="line">                                     i_block:第一个数据块号</span><br><span class="line"><span class="number">000019b</span>0  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br></pre></td></tr></table></figure><p>hello.txt的inode信息说明第一个数据块的块号为0x0201，对应偏移是0x400$\times$0x201&#x3D;0x80400，查看该地址处的数据块的内容。</p><h3 id="hello-txt的数据块"><a href="#hello-txt的数据块" class="headerlink" title="hello.txt的数据块"></a>hello.txt的数据块</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为hello.txt的第一个数据块</span></span><br><span class="line"><span class="number">00080400</span>  <span class="number">48</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6f</span> <span class="number">2</span>c <span class="number">20</span> <span class="number">77</span>  <span class="number">6f</span> <span class="number">72</span> <span class="number">6</span>c <span class="number">64</span> <span class="number">21</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">00</span>  |Hello, world!...|</span><br><span class="line"><span class="number">00080410</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br></pre></td></tr></table></figure><p>数据块中存储着hello.txt的ASCII码。</p><h3 id="lost-found的inode"><a href="#lost-found的inode" class="headerlink" title="lost+found的inode"></a>lost+found的inode</h3><p>根目录中lost+found目录的inode编号为0x0b，因此lost+found目录文件的inode地址为0x1400+0x80$\times$(0x0b-1)&#x3D;0x1900，在此处查看lost+found的inode信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为lost+found的inode</span></span><br><span class="line"><span class="number">00001900</span>  ed <span class="number">41</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">30</span> <span class="number">00</span> <span class="number">00</span>  d7 <span class="number">49</span> <span class="number">9</span>e <span class="number">5</span>e d7 <span class="number">49</span> <span class="number">9</span>e <span class="number">5</span>e  |.A..<span class="number">.0</span>...I.^.I.^|</span><br><span class="line"><span class="number">00001910</span>  d7 <span class="number">49</span> <span class="number">9</span>e <span class="number">5</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">18</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |.I.^............|</span><br><span class="line"><span class="number">00001920</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">26</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">27</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |........&amp;..<span class="number">.&#x27;</span>...|</span><br><span class="line">                                   ^_________^ ^_________^</span><br><span class="line">                                     i_block     i_block</span><br><span class="line">                                 第一个数据块标号  第二个数据块标号</span><br><span class="line"><span class="number">00001930</span>  <span class="number">28</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">29</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">2</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">2b</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |(...)...*...+...|</span><br><span class="line"><span class="number">00001940</span>  <span class="number">2</span>c <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">2</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">2</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">2f</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |,...-......./...|</span><br><span class="line"><span class="number">00001950</span>  <span class="number">30</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">31</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |<span class="number">0.</span>.<span class="number">.1</span>...........|</span><br><span class="line"><span class="number">00001960</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br></pre></td></tr></table></figure><p>lost+found第一个数据块的块号为0x0026，对应偏移是0x400$\times$0x26&#x3D;0x9800，查看该地址处的数据块的内容。</p><h3 id="lost-found数据块内容"><a href="#lost-found数据块内容" class="headerlink" title="lost+found数据块内容"></a>lost+found数据块内容</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为lost+found的目录项数据块</span></span><br><span class="line"><span class="number">00009800</span>  <span class="number">0b</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>c <span class="number">00</span> <span class="number">01</span> <span class="number">02</span>  <span class="number">2</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">          ^_________^ ^___^ ^^ ^^  ^_________^ ^_________^</span><br><span class="line">          inode       rec_len      name         inode</span><br><span class="line">                            ^name_len </span><br><span class="line">                               ^file_type      ^第<span class="number">2</span>个目录项</span><br><span class="line"><span class="number">00009810</span>  f4 <span class="number">03</span> <span class="number">02</span> <span class="number">02</span> <span class="number">2</span>e <span class="number">2</span>e <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">          ^___^ ^^ ^^ ^_________^</span><br><span class="line"><span class="number">00009820</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br><span class="line"><span class="number">00009</span>c00  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line"><span class="number">00009</span>c10  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">inode号</th><th align="center">目录项长度</th><th align="center">文件名长度</th><th align="center">文件类型</th><th align="center">文件名</th></tr></thead><tbody><tr><td align="center">0x0b</td><td align="center">0x0c: 12 Bytes</td><td align="center">0x1</td><td align="center">目录</td><td align="center">.</td></tr><tr><td align="center">0x02</td><td align="center">0x03f4Bytes</td><td align="center">0x2</td><td align="center">目录</td><td align="center">..</td></tr><tr><td align="center">当前目录inode指向自己，而上一级目录指向根目录。</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux程序执行与进程创建</title>
      <link href="/2022/05/06/OS_ELF_execve/"/>
      <url>/2022/05/06/OS_ELF_execve/</url>
      
        <content type="html"><![CDATA[<h1 id="一、程序的编译与执行"><a href="#一、程序的编译与执行" class="headerlink" title="一、程序的编译与执行"></a>一、程序的编译与执行</h1><h2 id="Program-Header"><a href="#Program-Header" class="headerlink" title="Program Header"></a>Program Header</h2><p>通常，我们写的代码都是编译、链接一气呵成，直接生成可执行文件，并且程序编译出来的虚拟起始地址通常是0x08048000，操作系统做了很多工作。例如将program.c编译和链接成可运行的文件:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc program.c -o program</span><br></pre></td></tr></table></figure><p>这其中经过了编译和链接两个步骤：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc program.c -o program.o</span><br><span class="line">gcc program.o -o program</span><br></pre></td></tr></table></figure><p>得到的program.o只是一个待重定位文件，文件里面的符号（函数和变量）还没有安排地址，将来在链接的时候与其他文件“组合”成一个可执行文件时再重新定位（安排地址）。“组合”指的就是链接。因为在编译期间不知道会链接那些文件，所以干脆在链接的阶段一起编址，形成一个可重定位文件。<br>程序之间调用的最简单的方式是$\verb+call+$和$\verb+jmp+$，例如BIOS调用MBR以及MBR调用Loader，MBR的物理地址是0x7c00，而Loader的地址可以是0x900，通常事先约定好调用地址。这种方法非常不灵活，因此一种灵活的方法便是程序的入口地址信息与程序绑定，在程序文件中专门腾出一个空间来写程序的入口地址、程序的大小等等信息。原先的可执行二进制文件(program body)加上新的文件头(program header)，就形成了一种新的文件格式这种具有程序头文件格式的程序文件从外存读入内存中后，从该程序文件的头读出程序入口地址，跨过程序头，跳转到入口地址执行。</p><h2 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h2><h3 id="ELF文件格式整体视图"><a href="#ELF文件格式整体视图" class="headerlink" title="ELF文件格式整体视图"></a>ELF文件格式整体视图</h3><p>Windows系统下的可执行文件格式是PE（Portable Executable，exe是文件拓展名，不是真正的格式），而Linux的可执行文件格式是ELF(Executable and Linkable Format，可执行连接格式)。ELF文件是经过编译和链接之后，可以直接运行的二进制可执行文件。Linux中的.o文件和可执行二进制文件都是ELF格式的文件。ELF文件格式可以在&#x2F;usr&#x2F;include&#x2F;elf.h中可以找到ELF文件格式的所有定义。<br>程序最重要的概念是段(segment)和节(section)，其中section是程序员在进行汇编程序设计时显示划分出的数据区、代码区、栈区等等，而不同程序在链接时，链接器将多个目标文件相同属性的section链接成一个segment，形成了可执行内存空间中的数据段、代码段等等。因此ELF格式重要有相应的数据结构来描述程序中不同的section和segment，一个段头(Program header，也叫程序头)用来描述一个段，一个节头(Section header)用来描述一个section，也就有了程序头表(Program header table，也可以称之为段头表)和节头表(Section header table)，本质就是用来分别存储段头和节头的两个数组。而程序头表和节头表的条目个数和表长也是不确定的，因此还需要另一个结构来描述程序头表和节头表，也就是ELF头(ELF Header)，因此整个ELF文件格式看起来如下图所示（图片来源：《操作系统真相还原》）。ELF文件格式真正的作用在链接和运行阶段，因此ELF文件格式布局也从这两方面展示。</p><head>    <meta charset="utf-8"><style>    .body{width:350px;height:200px}</style><h4 align="center">ELF文件格式视图</h4><table align="center" border="1" width="700px" cellspacing="7"><tr>    <td style="border: 1px solid black" align="center">链接视图</td>    <td style="border: 1px solid black" align="center">运行视图</td></tr><tr>    <td style="border: 1px solid black" align="center">ELF Header(elf头)</td>    <td style="border: 1px solid black" align="center">ELF Header(elf头)</td></tr><tr>    <td style="border: 1px solid black" align="center">Program Header Table(程序头表，非必须，可选)</td>    <td style="border: 1px solid black" align="center">Program Header Table(程序头表)</td></tr><tr>    <td style="border: 1px solid black" align="center">Section 1(节 1)</td>    <td style="border: 1px solid black" rowspan="2" align="center">Segment 1(段1)</td></tr><tr>    <td style="border: 1px solid black" align="center">...</th></tr><tr>    <td style="border: 1px solid black" align="center">...</th>    <td style="border: 1px solid black" rowspan="2" align="center">Segment 2(段2)</td></tr><tr>    <td style="border: 1px solid black" align="center">Section n(节 n)</th></tr><tr>    <td style="border: 1px solid black" align="center">...</th>    <td style="border: 1px solid black" align="center">...</th></tr><tr>    <td style="border: 1px solid black" align="center">Section Header Table(节头表)</td>    <td style="border: 1px solid black" align="center">Section Header Table(节头表，非必须，可选)</td></tr><tr>    <td style="border: 1px solid black" align="center">...</th>    <td style="border: 1px solid black" align="center">...</th></tr><tr>    <td class="body" style="border: 1px solid black" align="center">带重定位文件体(Program Body)</td>    <td class="body" style="border: 1px solid black" align="center">可执行文件体(Program Body)</td></tr></table><h3 id="ELF-Header数据结构"><a href="#ELF-Header数据结构" class="headerlink" title="ELF Header数据结构"></a>ELF Header数据结构</h3><p>ELF Header结构定义在&#x2F;usr&#x2F;include&#x2F;elf.h中的$\verb+struct Elf32_Ehdr+$中，结构体定义如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>e_ident[EI_NIDENT];    <span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf32_Halfe_type;        <span class="comment">/* Object file type */</span></span><br><span class="line">  Elf32_Halfe_machine;        <span class="comment">/* Architecture */</span></span><br><span class="line">  Elf32_Worde_version;        <span class="comment">/* Object file version */</span></span><br><span class="line">  Elf32_Addr    e_entry;        <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf32_Off     e_phoff;        <span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf32_Off     e_shoff;        <span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf32_Worde_flags;        <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf32_Halfe_ehsize;        <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf32_Halfe_phentsize;    <span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf32_Halfe_phnum;        <span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf32_Halfe_shentsize;    <span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf32_Halfe_shnum;        <span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf32_Halfe_shstrndx;        <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p>其中e_ident[16]是16字节大小的数组，用来表示魔数以及其他的信息，具体含义如下表所示。</p><head>    <meta charset="utf-8"><style>    .leftbody{width:300px;height:100px}    .rightbody{width:400px;height:100px}</style><h4 align="center">e_ident[16]数组</h4><table align="center" border="1" width="700px" cellspacing="7"><tr>    <td style="border: 1px solid black" align="center">e_ident[]成员</td>    <td style="border: 1px solid black" align="center">意义</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[0] = 0x7f</td>    <td style="border: 1px solid black" rowspan="4" align="center">这4位是ELF文件的魔数(magic number)，表明这是一个ELF文件，e_ident[1]~e_ident[3]这3个变量表示‘E’、‘L’、‘F’这三个字符</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[1] = 'E'</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[2] = 'L'</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[3] = 'F'</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[4]</td>    <td style="border: 1px solid black" align="center">ELF文件类型，值为0表示不可识别，值为1表示32位elf文件，值2表示64位elf文件</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[5]</td>    <td style="border: 1px solid black" align="center">编码格式，值为0：非法编码，值为1：小端字节序LSB，值为2：大端字节序MSB</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[6]</td>    <td style="border: 1px solid black" align="center">版本信息，默认为1</td></tr><tr>    <td class="leftbody" style="border: 1px solid black" align="center">e_ident[7～15]</td>    <td class="rightbody" style="border: 1px solid black" align="center">保留位，初始化为0</td></tr></table><p>而$\verb+struct Elf32_Ehdr+$中的所有成员的定义如下：</p><head>    <meta charset="utf-8"><style>    .leftbody{width:200px;height:30px}    .rightbody{width:500px;height:30px}</style><h4 align="center">struct Elf32_Ehdr成员定义</h4><table align="center" border="1" width="700px" cellspacing="7"><tr>    <td style="border: 1px solid black" align="center">e_ident[16]</td>    <td style="border: 1px solid black" align="center">魔数和其他信息</td></tr><tr>    <td style="border: 1px solid black" align="center">e_type</td>    <td style="border: 1px solid black" align="center">2字节，目标文件类型，值0：位置格式文件，值1：可重定位文件，值2：可执行文件，值3：动态共享目标文件，值4：core文件（程序崩溃时内存映像转储格式），其他值无需关注</td></tr><tr>    <td style="border: 1px solid black" align="center">e_machine</td>    <td style="border: 1px solid black" align="center">2字节，elf文件所属体系结构，值2：SPARC，值3：Intel 80386，值7：Intel 80860，值8：MPIS RS3000等等</td></tr><tr>    <td style="border: 1px solid black" align="center">e_version</td>    <td style="border: 1px solid black" align="center">4字节，版本信息</td></tr><tr>    <td style="border: 1px solid black" align="center">e_entry</td>    <td style="border: 1px solid black" align="center">4字节，操作系统运行该程序时，将控制权转交到的虚拟地址</td></tr><tr>    <td style="border: 1px solid black" align="center">e_phoff</td>    <td style="border: 1px solid black" align="center">4字节，程序头表(program header table)在文件内的字节偏移量，若没有程序头表，则该值为0</td></tr><tr>    <td style="border: 1px solid black" align="center">e_shoff</td>    <td style="border: 1px solid black" align="center">4字节，节头表(section header table)在文件内的字节偏移量，若没有节头表，则该值为0</td></tr><tr>    <td style="border: 1px solid black" align="center">e_flags</td>    <td style="border: 1px solid black" align="center">4字节，处理器相关的标志</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ehsize</td>    <td style="border: 1px solid black" align="center">2字节，elf header的字节大小</td></tr><tr>    <td style="border: 1px solid black" align="center">e_phentsize</td>    <td style="border: 1px solid black" align="center">2字节，程序头表(program header table)的每个条目(entry)的字节大小，该条目就是后面将要引出的struct Elf32_Phdr</td></tr><tr>    <td style="border: 1px solid black" align="center">e_phnum</td>    <td style="border: 1px solid black" align="center">2字节，程序头表(program header table)的条目(entry)个数，即程序中有多少个段</td></tr><tr>    <td style="border: 1px solid black" align="center">e_shentsize</td>    <td style="border: 1px solid black" align="center">2字节，节头表(section header table)的每个条目的字节大小</td></tr><tr>    <td style="border: 1px solid black" align="center">e_shnum</td>    <td style="border: 1px solid black" align="center">2字节，节头表(section header table)的条目个数</td></tr><tr>    <td class="leftbody" style="border: 1px solid black" align="center">e_shstrndx</td>    <td class="leftbody" style="border: 1px solid black" align="center">2字节，Section header string table在节头表中的索引</td></tr></table><p>接下来是程序头表中条目的数据结构，也就是用来描述各个段(segment)的信息，其结构体为$\verb+struct Elf32_Phdr+$，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Program segment header.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Wordp_type;<span class="comment">/* Segment type */</span></span><br><span class="line">  Elf32_Off    p_offset;<span class="comment">/* Segment file offset */</span></span><br><span class="line">  Elf32_Addrp_vaddr;<span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf32_Addrp_paddr;<span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf32_Wordp_filesz;<span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf32_Wordp_memsz;<span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf32_Wordp_flags;<span class="comment">/* Segment flags */</span></span><br><span class="line">  Elf32_Wordp_align;<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure><p>结构体中的各个成员的信息如下表所示：</p><head>    <meta charset="utf-8"><style>    .leftbody{width:200px;height:30px}    .rightbody{width:500px;height:30px}</style><h4 align="center">struct Elf32_Phdr成员定义</h4><table align="center" border="1" width="700px" cellspacing="7"><tr>    <td style="border: 1px solid black" align="center">p_type</td>    <td style="border: 1px solid black" align="center">4字节，表示程序中该段的类型，值1：可加载程序段，值2：动态链接信息，值3：动态加载器名称，值6：程序头表，以及其他无需关注的信息</td></tr><tr>    <td style="border: 1px solid black" align="center">p_offset</td>    <td style="border: 1px solid black" align="center">4字节，本段在文件内的起始偏移地址</td></tr><tr>    <td style="border: 1px solid black" align="center">p_vaddr</td>    <td style="border: 1px solid black" align="center">4字节，本段在内存中的起始虚拟地址</td></tr><tr>    <td style="border: 1px solid black" align="center">p_paddr</td>    <td style="border: 1px solid black" align="center">4字节，仅用于与物理地址相关的系统如System V中</td></tr><tr>    <td style="border: 1px solid black" align="center">p_filesz</td>    <td style="border: 1px solid black" align="center">4字节，本段在文件中的大小</td></tr><tr>    <td style="border: 1px solid black" align="center">p_memsz</td>    <td style="border: 1px solid black" align="center">4字节，本段在内存中的大小</td></tr><tr>    <td style="border: 1px solid black" align="center">p_flags</td>    <td style="border: 1px solid black" align="center">4字节，本段相关的标志，0b1：可执行，0b10：可写，0b100：可读，以及其他标志</td></tr><tr>    <td class="leftbody" style="border: 1px solid black" align="center">p_align</td>    <td class="rightbody" style="border: 1px solid black" align="center">4字节，本段在内存和文件中的对齐方式，若值为0或值1，则不对齐，否则其为2的幂次</td></tr></table><h3 id="实验程序实例"><a href="#实验程序实例" class="headerlink" title="实验程序实例"></a>实验程序实例</h3><p>一共两个程序，分别为parent.c和child.c，其中在parent.c中父进程会$\verb+fork+$一个子进程，子进程会利用$\verb+execve+$系统调用来将child.c加载进自己的进程空间，执行这一段新的程序。<br>这个是父进程执行的程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*parent.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str1[<span class="number">4096</span>] = &#123;<span class="string">&quot;String of parent process.\n&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)             <span class="comment">/*Error occured*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Fork failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)            <span class="comment">/*Child process*/</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str1);</span><br><span class="line">        <span class="built_in">strcpy</span>(str1, <span class="string">&quot;String of child process.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str1);</span><br><span class="line">        <span class="built_in">execve</span>(<span class="string">&quot;./child&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                    <span class="comment">/*Parent process*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str1, <span class="string">&quot;Running in parent process.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是子进程加载的新程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*child.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str2[<span class="number">4096</span>] = &#123;<span class="string">&quot;Child process is runing another program!\n&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>* ptr2 = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(str2) + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(ptr2, <span class="number">0</span>, <span class="built_in">sizeof</span>(ptr2));</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr2, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, ptr2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ELF-Header实例"><a href="#ELF-Header实例" class="headerlink" title="ELF Header实例"></a>ELF Header实例</h3><p>可以利用xxd命令来查看ELF文件格式信息，新建一个xxd.sh脚本，其内容为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxd -g <span class="number">1</span> -s $<span class="number">2</span> -l $<span class="number">3</span> $<span class="number">1</span></span><br></pre></td></tr></table></figure><p>然后在命令行中输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh ./xxd.sh ./child <span class="number">0</span> <span class="number">300</span></span><br></pre></td></tr></table></figure><p>即可查看child文件的ELF格式信息。上面参数的意思是查看0~300字节的ELF文件格式信息。在学校提供的实验平台上得到的结果如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span>: <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">01</span> <span class="number">01</span> <span class="number">01</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  .ELF............</span><br><span class="line"><span class="number">00000010</span>: <span class="number">02</span> <span class="number">00</span> <span class="number">03</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>a <span class="number">8</span>d <span class="number">04</span> <span class="number">08</span> <span class="number">34</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ...........<span class="number">.4</span>...</span><br><span class="line"><span class="number">00000020</span>: <span class="number">0</span>c <span class="number">34</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">34</span> <span class="number">00</span> <span class="number">20</span> <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">28</span> <span class="number">00</span>  <span class="number">.4</span>.....<span class="number">.4</span>. ...(.</span><br><span class="line"><span class="number">00000030</span>: <span class="number">24</span> <span class="number">00</span> <span class="number">21</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> <span class="number">04</span> <span class="number">08</span>  $.!.............</span><br><span class="line"><span class="number">00000040</span>: <span class="number">00</span> <span class="number">80</span> <span class="number">04</span> <span class="number">08</span> <span class="number">6f</span> <span class="number">00</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">6f</span> <span class="number">00</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ....o...o.......</span><br><span class="line"><span class="number">00000050</span>: <span class="number">00</span> <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">58</span> <span class="number">0f</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">58</span> <span class="number">9f</span> <span class="number">0</span>e <span class="number">08</span>  ........X...X...</span><br><span class="line"><span class="number">00000060</span>: <span class="number">58</span> <span class="number">9f</span> <span class="number">0</span>e <span class="number">08</span> <span class="number">48</span> <span class="number">20</span> <span class="number">00</span> <span class="number">00</span> cc <span class="number">33</span> <span class="number">00</span> <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  X...H ..<span class="number">.3</span>......</span><br><span class="line"><span class="number">00000070</span>: <span class="number">00</span> <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> f4 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> f4 <span class="number">80</span> <span class="number">04</span> <span class="number">08</span>  ................</span><br><span class="line"><span class="number">00000080</span>: f4 <span class="number">80</span> <span class="number">04</span> <span class="number">08</span> <span class="number">44</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">44</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ....D...D.......</span><br><span class="line"><span class="number">00000090</span>: <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">58</span> <span class="number">0f</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">58</span> <span class="number">9f</span> <span class="number">0</span>e <span class="number">08</span>  ........X...X...</span><br><span class="line"><span class="number">000000</span>a0: <span class="number">58</span> <span class="number">9f</span> <span class="number">0</span>e <span class="number">08</span> <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">28</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  X.......(.......</span><br><span class="line"><span class="number">000000b</span>0: <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">51</span> e5 <span class="number">74</span> <span class="number">64</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ....Q.td........</span><br><span class="line"><span class="number">000000</span>c0: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ................</span><br><span class="line"><span class="number">000000</span>d0: <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">52</span> e5 <span class="number">74</span> <span class="number">64</span> <span class="number">58</span> <span class="number">0f</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">58</span> <span class="number">9f</span> <span class="number">0</span>e <span class="number">08</span>  ....R.tdX...X...</span><br><span class="line"><span class="number">000000e0</span>: <span class="number">58</span> <span class="number">9f</span> <span class="number">0</span>e <span class="number">08</span> a8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> a8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  X...............</span><br><span class="line"><span class="number">000000f</span>0: <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ................</span><br><span class="line"><span class="number">00000100</span>: <span class="number">47</span> <span class="number">4</span>e <span class="number">55</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  GNU.............</span><br><span class="line"><span class="number">00000110</span>: <span class="number">18</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">14</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ................</span><br><span class="line"><span class="number">00000120</span>: <span class="number">47</span> <span class="number">4</span>e <span class="number">55</span> <span class="number">00</span> d9 <span class="number">5</span>e <span class="number">23</span> cf b2 <span class="number">2</span>c <span class="number">61</span> f1              GNU..^#..,a.</span><br></pre></td></tr></table></figure><p>因此child文件的ELF格式信息具体含义如下，其中0x00到0x33号内存单元是ELF Header(即$\verb+struct Elf+$)的内容，0x34到0xf4为program header(即$\verb+struct Elf32_Phdr+$)得内容，首先分析ELF Header信息：</p><head>    <meta charset="utf-8"><style>    .leftbody{width:150px;height:30px}    .midbody{width:150;height:300}    .rightbody{width:400px;height:30px}</style><h4 align="center">child文件的ELF Header信息</h4><table align="center" border="1" width="700px" cellspacing="7"><tr>    <td style="border: 1px solid black" align="center">成员</td>    <td style="border: 1px solid black" align="center">值</td>    <td style="border: 1px solid black" align="center">含义</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[4]</td>    <td style="border: 1px solid black" align="center">0x01</td>    <td style="border: 1px solid black" align="center">32位的elf文件</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[5]</td>    <td style="border: 1px solid black" align="center">0x01</td>    <td style="border: 1px solid black" align="center">小端字节序</td></tr><tr>    <td style="border: 1px solid black" align="center">e_type</td>    <td style="border: 1px solid black" align="center">0x0002</td>    <td style="border: 1px solid black" align="center">可执行文件</td></tr><tr>    <td style="border: 1px solid black" align="center">e_machine</td>    <td style="border: 1px solid black" align="center">0x0003</td>    <td style="border: 1px solid black" align="center">intel 80386平台</td></tr><tr>    <td style="border: 1px solid black" align="center">e_entry</td>    <td style="border: 1px solid black" align="center">0x08048d0a</td>    <td style="border: 1px solid black" align="center">程序的虚拟入口地址为0x08048d0a</td></tr><tr>    <td style="border: 1px solid black" align="center">e_phoff</td>    <td style="border: 1px solid black" align="center">0x00000034</td>    <td style="border: 1px solid black" align="center">程序头表在文件中的偏移量是0x34</td></tr><tr>    <td style="border: 1px solid black" align="center">e_shoff</td>    <td style="border: 1px solid black" align="center">0x000a340c</td>    <td style="border: 1px solid black" align="center">节头表在文件中的偏移量</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ehsize</td>    <td style="border: 1px solid black" align="center">0x0034</td>    <td style="border: 1px solid black" align="center">elf header大小为0x34，可见程序头表后面跟着elf头</td></tr><tr>    <td style="border: 1px solid black" align="center">e_phentsize</td>    <td style="border: 1px solid black" align="center">0x0020</td>    <td style="border: 1px solid black" align="center">程序头表program header每个条目(struct Elf32_Phdr)的大小为0x20</td></tr><tr>    <td style="border: 1px solid black" align="center">e_phnum</td>    <td style="border: 1px solid black" align="center">0x0006</td>    <td style="border: 1px solid black" align="center">程序头表中的元素个数为6，即有6个段</td></tr><tr>    <td style="border: 1px solid black" align="center">e_shentsize</td>    <td style="border: 1px solid black" align="center">0x0028</td>    <td style="border: 1px solid black" align="center">节头表中各个节的大小</td></tr><tr>    <td style="border: 1px solid black" align="center">e_shnum</td>    <td style="border: 1px solid black" align="center">0x0024</td>    <td style="border: 1px solid black" align="center">节头表中元素个数，说明一共0x24=36个节</td></tr><tr>    <td class="leftbody" style="border: 1px solid black" align="center">e_shstrndx</td>    <td class="midbody" style="border: 1px solid black" align="center">0x0021</td>    <td class="rightbody" style="border: 1px solid black" align="center">string name table在节头表中的索引为0x21</td></tr></table><p>然后分析程序头表program header的内容(第4行的0x34开始)，刚才ELF Header中可以知道，程序一共有6个段，且每个段的条目的大小为0x20。</p><head>    <meta charset="utf-8"><style>    .leftbody{width:150px;height:30px}    .midbody{width:150;height:300}    .rightbody{width:400px;height:30px}</style><h4 align="center">child文件的Program Header信息</h4><table align="center" border="1" width="700px" cellspacing="7"><tr>    <td style="border: 1px solid black" align="center">成员</td>    <td style="border: 1px solid black" align="center">值</td>    <td style="border: 1px solid black" align="center">含义</td></tr><tr>    <td style="border: 1px solid black" align="center">p_type</td>    <td style="border: 1px solid black" align="center">0x00000001</td>    <td style="border: 1px solid black" align="center">该程序为可加载程序段</td></tr><tr>    <td style="border: 1px solid black" align="center">p_offset</td>    <td style="border: 1px solid black" align="center">0x00000000</td>    <td style="border: 1px solid black" align="center">本段在文件内的偏移量为0x00</td></tr><tr>    <td style="border: 1px solid black" align="center">p_vaddr</td>    <td style="border: 1px solid black" align="center">0x08048000</td>    <td style="border: 1px solid black" align="center">该段被加载到内存后的起始虚拟地址！Elf Header中的e_entry是整个程序的入口地址(0x08048d0a)，而整个程序的起始地址是0x08048000。</td></tr><tr>    <td style="border: 1px solid black" align="center">p_paddr</td>    <td style="border: 1px solid black" align="center">0x08048000</td>    <td style="border: 1px solid black" align="center">和p_vaddr相似，不用管这个</td></tr><tr>    <td style="border: 1px solid black" align="center">p_filesz</td>    <td style="border: 1px solid black" align="center">0x000a006f</td>    <td style="border: 1px solid black" align="center">本段在文件中的字节大小</td></tr><tr>    <td style="border: 1px solid black" align="center">p_memsz</td>    <td style="border: 1px solid black" align="center">0x000a006f</td>    <td style="border: 1px solid black" align="center">本段在内存中的字节大小，等于p_filesz</td></tr><tr>    <td style="border: 1px solid black" align="center">p_flags</td>    <td style="border: 1px solid black" align="center">0x00000005</td>    <td style="border: 1px solid black" align="center">5=4+1，因此该段可读可执行，据此推测出该段应该是代码段。</td></tr><tr>    <td class="leftbody" style="border: 1px solid black" align="center">p_align</td>    <td class="midbody" style="border: 1px solid black" align="center">0x00001000</td>    <td class="rightbody" style="border: 1px solid black" align="center">本段的对齐方式为32字节对齐</td></tr></table><p>接下来看数据段的信息，在gdb调试窗口中打印str2的地址，为0x80ea080，并且数据段线性区的地址范围为0x80e9000到0x80ec000。<br>除了利用xxd命令查看ELF文件格式外，还可以利用readelf命令来查看。简单的输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -e child</span><br></pre></td></tr></table></figure><p>即可得到如下信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">01</span> <span class="number">01</span> <span class="number">01</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  Class:                             ELF32</span><br><span class="line">  Data:                              <span class="number">2&#x27;</span>s complement, little endian</span><br><span class="line">  Version:                           <span class="number">1</span> (current)</span><br><span class="line">  OS/ABI:                            UNIX - GNU</span><br><span class="line">  ABI Version:                       <span class="number">0</span></span><br><span class="line">  Type:                              <span class="built_in">EXEC</span> (Executable file)</span><br><span class="line">  Machine:                           Intel <span class="number">80386</span></span><br><span class="line">  Version:                           <span class="number">0x1</span></span><br><span class="line">  Entry point address:               <span class="number">0x8048d0a</span></span><br><span class="line">  Start of program headers:          <span class="number">52</span> (bytes into file)</span><br><span class="line">  Start of section headers:          <span class="number">668684</span> (bytes into file)</span><br><span class="line">  Flags:                             <span class="number">0x0</span></span><br><span class="line">  Size of <span class="keyword">this</span> header:               <span class="number">52</span> (bytes)</span><br><span class="line">  Size of program headers:           <span class="number">32</span> (bytes)</span><br><span class="line">  Number of program headers:         <span class="number">6</span></span><br><span class="line">  Size of section headers:           <span class="number">40</span> (bytes)</span><br><span class="line">  Number of section headers:         <span class="number">36</span></span><br><span class="line">  Section header string table index: <span class="number">33</span></span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>            <span class="number">00000000</span> <span class="number">000000</span> <span class="number">000000</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .note.ABI-tag     NOTE            <span class="number">080480f</span>4 <span class="number">0000f</span>4 <span class="number">000020</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">2</span>] .note.gnu.build-i NOTE            <span class="number">08048114</span> <span class="number">000114</span> <span class="number">000024</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">3</span>] .rel.plt          REL             <span class="number">08048138</span> <span class="number">000138</span> <span class="number">000070</span> <span class="number">08</span>   A  <span class="number">0</span>   <span class="number">5</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">4</span>] .init             PROGBITS        <span class="number">080481</span>a8 <span class="number">0001</span>a8 <span class="number">000023</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .plt              PROGBITS        <span class="number">080481</span>d0 <span class="number">0001</span>d0 <span class="number">0000e0</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span> <span class="number">16</span></span><br><span class="line">  [ <span class="number">6</span>] .text             PROGBITS        <span class="number">080482b</span>0 <span class="number">0002b</span>0 <span class="number">075134</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span> <span class="number">16</span></span><br><span class="line">  [ <span class="number">7</span>] __libc_freeres_fn PROGBITS        <span class="number">080b</span>d3f0 <span class="number">0753f</span>0 <span class="number">000</span>ad6 <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span> <span class="number">16</span></span><br><span class="line">  [ <span class="number">8</span>] __libc_thread_fre PROGBITS        <span class="number">080b</span>ded0 <span class="number">075</span>ed0 <span class="number">00006f</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span> <span class="number">16</span></span><br><span class="line">  [ <span class="number">9</span>] .fini             PROGBITS        <span class="number">080b</span>df40 <span class="number">075f</span>40 <span class="number">000014</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">10</span>] .rodata           PROGBITS        <span class="number">080b</span>df60 <span class="number">075f</span>60 <span class="number">01b</span>f90 <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span> <span class="number">32</span></span><br><span class="line">  [<span class="number">11</span>] __libc_subfreeres PROGBITS        <span class="number">080</span>d9ef0 <span class="number">091</span>ef0 <span class="number">00002</span>c <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">12</span>] __libc_atexit     PROGBITS        <span class="number">080</span>d9f1c <span class="number">091f</span>1c <span class="number">000004</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">13</span>] __libc_thread_sub PROGBITS        <span class="number">080</span>d9f20 <span class="number">091f</span>20 <span class="number">000004</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">14</span>] .eh_frame         PROGBITS        <span class="number">080</span>d9f24 <span class="number">091f</span>24 <span class="number">00e0</span>a8 <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">15</span>] .gcc_except_table PROGBITS        <span class="number">080e7</span>fcc <span class="number">09f</span>fcc <span class="number">0000</span>a3 <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">16</span>] .tdata            PROGBITS        <span class="number">080e9</span>f58 <span class="number">0</span>a0f58 <span class="number">000010</span> <span class="number">00</span> WAT  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">17</span>] .tbss             NOBITS          <span class="number">080e9</span>f68 <span class="number">0</span>a0f68 <span class="number">000018</span> <span class="number">00</span> WAT  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">18</span>] .init_array       INIT_ARRAY      <span class="number">080e9</span>f68 <span class="number">0</span>a0f68 <span class="number">000008</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">19</span>] .fini_array       FINI_ARRAY      <span class="number">080e9</span>f70 <span class="number">0</span>a0f70 <span class="number">000008</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">20</span>] .jcr              PROGBITS        <span class="number">080e9</span>f78 <span class="number">0</span>a0f78 <span class="number">000004</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">21</span>] .data.rel.ro      PROGBITS        <span class="number">080e9</span>f80 <span class="number">0</span>a0f80 <span class="number">000070</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span> <span class="number">32</span></span><br><span class="line">  [<span class="number">22</span>] .got              PROGBITS        <span class="number">080e9</span>ff0 <span class="number">0</span>a0ff0 <span class="number">000008</span> <span class="number">04</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">23</span>] .got.plt          PROGBITS        <span class="number">080</span>ea000 <span class="number">0</span>a1000 <span class="number">000044</span> <span class="number">04</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">24</span>] .data             PROGBITS        <span class="number">080</span>ea060 <span class="number">0</span>a1060 <span class="number">001f</span>40 <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span> <span class="number">32</span></span><br><span class="line">  [<span class="number">25</span>] .bss              NOBITS          <span class="number">080</span>ebfa0 <span class="number">0</span>a2fa0 <span class="number">00136</span>c <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span> <span class="number">32</span></span><br><span class="line">  [<span class="number">26</span>] __libc_freeres_pt NOBITS          <span class="number">080</span>ed30c <span class="number">0</span>a2fa0 <span class="number">000018</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">27</span>] .comment          PROGBITS        <span class="number">00000000</span> <span class="number">0</span>a2fa0 <span class="number">00002b</span> <span class="number">01</span>  MS  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">28</span>] .debug_aranges    PROGBITS        <span class="number">00000000</span> <span class="number">0</span>a2fcb <span class="number">000020</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">29</span>] .debug_info       PROGBITS        <span class="number">00000000</span> <span class="number">0</span>a2feb <span class="number">0000</span>dd <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">30</span>] .debug_abbrev     PROGBITS        <span class="number">00000000</span> <span class="number">0</span>a30c8 <span class="number">0000</span>a0 <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">31</span>] .debug_line       PROGBITS        <span class="number">00000000</span> <span class="number">0</span>a3168 <span class="number">00004</span>d <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">32</span>] .debug_str        PROGBITS        <span class="number">00000000</span> <span class="number">0</span>a31b5 <span class="number">0000</span>cb <span class="number">01</span>  MS  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">33</span>] .shstrtab         STRTAB          <span class="number">00000000</span> <span class="number">0</span>a3280 <span class="number">00018</span>c <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">34</span>] .symtab           SYMTAB          <span class="number">00000000</span> <span class="number">0</span>a39ac <span class="number">008</span>c00 <span class="number">10</span>     <span class="number">35</span> <span class="number">1060</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">35</span>] .strtab           STRTAB          <span class="number">00000000</span> <span class="number">0</span>ac5ac <span class="number">007</span>ebd <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  <span class="built_in">W</span> (write), <span class="built_in">A</span> (alloc), <span class="built_in">X</span> (execute), <span class="built_in">M</span> (merge), <span class="built_in">S</span> (strings)</span><br><span class="line">  <span class="built_in">I</span> (info), <span class="built_in">L</span> (link order), <span class="built_in">G</span> (group), <span class="built_in">T</span> (TLS), <span class="built_in">E</span> (exclude), <span class="built_in">x</span> (unknown)</span><br><span class="line">  <span class="built_in">O</span> (extra OS processing required) <span class="built_in">o</span> (OS specific), <span class="built_in">p</span> (processor specific)</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span><br><span class="line">  LOAD           <span class="number">0x000000</span> <span class="number">0x08048000</span> <span class="number">0x08048000</span> <span class="number">0xa006f</span> <span class="number">0xa006f</span> R E <span class="number">0x1000</span></span><br><span class="line">  LOAD           <span class="number">0x0a0f58</span> <span class="number">0x080e9f58</span> <span class="number">0x080e9f58</span> <span class="number">0x02048</span> <span class="number">0x033cc</span> RW  <span class="number">0x1000</span></span><br><span class="line">  NOTE           <span class="number">0x0000f4</span> <span class="number">0x080480f4</span> <span class="number">0x080480f4</span> <span class="number">0x00044</span> <span class="number">0x00044</span> R   <span class="number">0x4</span></span><br><span class="line">  TLS            <span class="number">0x0a0f58</span> <span class="number">0x080e9f58</span> <span class="number">0x080e9f58</span> <span class="number">0x00010</span> <span class="number">0x00028</span> R   <span class="number">0x4</span></span><br><span class="line">  GNU_STACK      <span class="number">0x000000</span> <span class="number">0x00000000</span> <span class="number">0x00000000</span> <span class="number">0x00000</span> <span class="number">0x00000</span> RW  <span class="number">0x10</span></span><br><span class="line">  GNU_RELRO      <span class="number">0x0a0f58</span> <span class="number">0x080e9f58</span> <span class="number">0x080e9f58</span> <span class="number">0x000a8</span> <span class="number">0x000a8</span> R   <span class="number">0x1</span></span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   <span class="number">00</span>     .note.ABI-tag .note.gnu.build-id .rel.plt .init .plt .text __libc_freeres_fn __libc_thread_freeres_fn .fini .rodata __libc_subfreeres __libc_atexit __libc_thread_subfreeres .eh_frame .gcc_except_table</span><br><span class="line">   <span class="number">01</span>     .tdata .init_array .fini_array .jcr .data.rel.ro .got .got.plt .data .bss __libc_freeres_ptrs</span><br><span class="line">   <span class="number">02</span>     .note.ABI-tag .note.gnu.build-id</span><br><span class="line">   <span class="number">03</span>     .tdata .tbss</span><br><span class="line">   <span class="number">04</span></span><br><span class="line">   <span class="number">05</span>     .tdata .init_array .fini_array .jcr .data.rel.ro .got</span><br></pre></td></tr></table></figure><p>上面包含了ELF Header，所有Program Header以及Section Header的信息，最后还指明了每个section会整合进哪一个segment中，可以看到数据段应该是第2个segment。</p><h1 id="进程的创建与程序加载"><a href="#进程的创建与程序加载" class="headerlink" title="进程的创建与程序加载"></a>进程的创建与程序加载</h1><h2 id="整体视图"><a href="#整体视图" class="headerlink" title="整体视图"></a>整体视图</h2><p>在shell终端输入.&#x2F;parent，shell进程会调用fork()和execve()来创建新进程并加载.&#x2F;parent文件映像到父进程空间，然后parent进程又会同样调用fork()和execve()来创建新进程并加载.&#x2F;child文件映像到子进程空间。</p><div style = "align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB680b0b8f4b6098490039e8f6a025de95?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="40%" height="40%"/> <h2 id="Fork系统调用"><a href="#Fork系统调用" class="headerlink" title="Fork系统调用"></a>Fork系统调用</h2><p>fork函数的原型是$\verb+pid_t fork(void)+$，返回值有3种：子进程pid、0、-1。如果fork失败，那么返回-1。为了让父进程知道自己创建的子进程号，fork会给父进程返回子进程的pid，并且没有pid为0的的进程，因此fork给子进程返回0，通过返回值将父子进程区分开。调用fork之后，子进程会完全拷贝父进程的地址空间，因此两份进程的代码是一样的，只不过子进程是在fork系统调用才开始执行代码的，两者在$if$语句分道扬镳，就像一个叉子一样。<br>在Unix系统中提供了3种创建进程相关的系统调用: fork、vfork和clone，三种系统调用的区别如下：</p><table><thead><tr><th align="center">系统调用</th><th align="center">区别</th></tr></thead><tbody><tr><td align="center">fork</td><td align="center">无参数，子进程是父进程完整拷贝：复制父进程所有资源包括地址空间(mm_struct:包含指向页目录表和页表的指针)、页表、打开文件表、信号处理等，新版内核增加了写时复制COW，fork的代价仅剩拷贝父进程页表</td></tr><tr><td align="center">vfork</td><td align="center">无参数，父子进程共享地址空间：同一个mm_struct，无需复制，子进程完全运行在父进程的地址空间上，因此子进程修改变量，父进程的变量也会改变。为防止父进程重写子进程需要的数据，阻塞父进程执行，直到子进程退出或者使用exec加载新的程序</td></tr><tr><td align="center">clone</td><td align="center">有参数，父进程的资源有选择性的拷贝给子进程：clone_flags参数共享哪些资源，其余资源进行复制</td></tr></tbody></table><p>在调用fork系统调用时，创建的新任务具有父进程的所有相关数据的副本，更高版本的内核增加了写时复制(Copy On Write)，父子进程共享一组资源，例如数据段，设置为只读，如果子进程修改了数据段中的变量，数据段中的内容拷贝到新的内存中再进行修改，因此子进程对变量修改不会影响父进程。调用clone系统调用时，创建的新任务并不具有所有数据的拷贝，clone_flags参数决定共享哪些资源，例如$\verb+CLONE_VM+$决定共享相同的内存空间，$\verb+CLONE_FILES+$决定共享相同的打开文件。如果不设置这些参数，那么clone与fork功能类似。在内核中三种函数的执行流程如下：</p><div style = "align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEBc958d4e5ba53bf36d8f1c91908b8483c?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="40%" height="40%"/>  <ul><li>注：在Linux中fork()利用clone()来实现，在C程序中调用fork()函数会触发120号系统调用clone，不会触发2号系统调用fork！我猜应该是Linux中采用了写时复制技术，很多资源父子进程共享，所以不用全部拷贝，部份拷贝，其余资源共享即可，所以用clone系统调用。（以上过程在i386-32位平台上实现）</li></ul><p>因此，parent.c程序中执行fork和execve系统调用时，数据段中的str1字符串发生的改变如下：<br>1、刚进入main函数，父进程指向str1所在物理页面，且页面可写；</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB220b71cadf3b1b5bac4278836e4a0316?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/>  <p>2、fork()函数执行后，父子进程共同指向str1物理页面，且页面只读；</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB3721974e0a188301cfda36c6af2c619f?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/>  <p>3、子进程试图修改str1的内容，发生写时复制，str1拷贝到新内存区域防止篡改父进程数据；</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB57c257d4ead121d8bc11a07729ae3391?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/> <p>4、执行execve后子进程的mm_struct以及页目录项、页表项全部改变；</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEBbf788e3c7683fe13a889e12fcb327420?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/> <p>如果将C程序中的fork()改为vfork()，则父子进程的mm_struct、页目录和页表项均共享，可以直接篡改对方进程的数据：</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEBeba8d4cdae87b5cff22f3f2d04def660?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/> <h2 id="Execve系统调用"><a href="#Execve系统调用" class="headerlink" title="Execve系统调用"></a>Execve系统调用</h2><p>execve()函数是exec函数家族的一员，exec函数簇的6个函数功能类似，差别在于程序变量的表示方式和是否传入环境变量。exec会将可执行文件的绝对路径作为参数，把当前正在运行的用户的进程体（代码段、数据段、堆、栈、）用该可执行文件的进程体替换。<br>在shell终端输入一个可执行程序的文件名，shell程序会先用fork系统调用创建子进程，然后再调用execve系统调用，利用新的可执行文件的进程体替换fork出来的子进程的进程体，从而实现新进程执行完全不一样的新程序。<br>execve函数定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><p>三个参数分别是是可执行文件名、命令行参数和环境变量。execve()函数执行的主要轨迹如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">execve</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sys_execve</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">do_execve</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">do_execveat_common</span>()                        <span class="comment">//完成struct linux_binprm bprm初始化</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">load_elf_binary</span>()</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">load_elf_phdrs</span>();                   <span class="comment">//读取所有的程序头</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; e_phnum; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e_type != PT_LOAD) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="built_in">elf_map</span>();            <span class="comment">//mmap代码段和数据段，并建立用户进程到文件页高速缓存</span></span><br><span class="line">                    &#125;                         <span class="comment">//的映射关系，同时创建vm_area_struct</span></span><br><span class="line">                    <span class="built_in">start_thread</span>()</span><br><span class="line">                    &#123;</span><br><span class="line">                        regs-&gt;ip = new_ip;              <span class="comment">//入口地址设置为elf header中的e_entry</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure><p>exec函数簇的6个函数最终都会执行execve()系统调用，在sys_execve()服务例程中，do_execve()函数调用do_execveat_common()来完成结构体$\verb+struct linux_binprm bprm+$的初始化，用来记录可执行文件的信息。该函数还会调用path_look_up()和dentry_open()获得可执行文件相关的目录项对象、文件对象和inode对象（《深入理解Linux内核》），执行完该函数后，进入load_elf_binary()函数之前，$\verb+struct linux_binprm bprm+$中的内容如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  buf = <span class="string">&quot;\177ELF\001\001\001\003\000\000\000\000\000\000\000\000\002\000\003\000\001</span></span><br><span class="line"><span class="string">  \000\000\000\n\215\004\b4\000\000\000\f4\n\000\000\000\000\000\064\000 \000\006\000</span></span><br><span class="line"><span class="string">  (\000$\000!\000\001\000\000\000\000\000\000\000\000\200\004\b\000\200\004\bo\000\n</span></span><br><span class="line"><span class="string">  \000o\000\n\000\005\000\000\000\000\020\000\000\001\000\000\000X\017\n\000X\237\016</span></span><br><span class="line"><span class="string">  \bX\237\016\bH\000\000\314\063\000\000\006\000\000\000\000\020\000\000\004\000\000</span></span><br><span class="line"><span class="string">  \000\364\000\000\000\364\200\004\b&quot;</span>, vma = <span class="number">0xc011c528</span>,</span><br><span class="line">  vma_pages = <span class="number">2</span>, mm = <span class="number">0xc5cc7a40</span>, p = <span class="number">3221225460</span>, cred_prepared = <span class="number">1</span>,</span><br><span class="line">  cap_effective = <span class="number">1</span>, recursion_depth = <span class="number">1</span>, file = <span class="number">0xc7542300</span>,</span><br><span class="line">  cred = <span class="number">0xc6393640</span>, unsafe = <span class="number">0</span>, per_clear = <span class="number">0</span>, argc = <span class="number">0</span>, envc = <span class="number">0</span>,</span><br><span class="line">  filename = <span class="number">0xc75353d0</span> <span class="string">&quot;./child&quot;</span>, interp = <span class="number">0xc75353d0</span> <span class="string">&quot;./child&quot;</span>,</span><br><span class="line">  interp_flags = <span class="number">0</span>, interp_data = <span class="number">0</span>, loader = <span class="number">0</span>, exec = <span class="number">3221225460</span>&#125;</span><br></pre></td></tr></table></figure><p>其中buf为128字节，这些字节包含的是ELF文件格式的魔数和其他信息（即ELF Header），用八进制表示，可以看到开头的’\177ELF’就是前面说到的ELF Header的开头几个魔数。并且此时的vma(vm_area_Struct)和mm(mm_struct)已经分配好了但是还没有初始化，将来会用新的mm和vma来替换当前的mm和vma。会在接下来的load_elf_binary()函数中完成该过程。<br>此时内存的情况如下所示：</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEBa0ad675812fc28302e56120229572181?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/> <p>load_elf_binary()函数为可执行文件的接口，执行的过程如下：</p><ul><li><p>1、动态创建一个结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> </span><br><span class="line"> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">elfhdr</span> elf_ex;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">elfhdr</span> interp_elf_ex;</span><br><span class="line"> &#125; *loc;</span><br></pre></td></tr></table></figure><p>然后从传入参数的bprm-&gt;buf中获得elf header的信息，并进行校验：魔数必须匹配，程序的类型必须为ET_EXEC或者ET_DYN，检查bprm-&gt;file-&gt;f_op-&gt;mmap，指向的文件是否已经映射到内存中；</p></li><li><p>2、查找解释器段<br>遍历所有程序头（一共6个），通过遍历每个段，找到PT_INTERP类型段，也即是解释器段，找到说明需要运行过程中的动态链接。“解释器”段实际上只是一个字符串，即解释器的文件名，最终记录在elf_interpreter变量中。另外child程序是静态编译的程序，不需要动态链接，也就没有解析器段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">elf_phdata = <span class="built_in">load_elf_phdrs</span>(&amp;loc-&gt;elf_ex, bprm-&gt;file);</span><br><span class="line">elf_ppnt = elf_phdata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loc-&gt;elf_ex.e_phnum; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (elf_ppnt-&gt;p_type == PT_INTERP) </span><br><span class="line">      &#123;</span><br><span class="line">          ...</span><br><span class="line">elf_interpreter = <span class="built_in">kmalloc</span>(elf_ppnt-&gt;p_filesz, GFP_KERNEL);</span><br><span class="line">          <span class="comment">//根据其位置的p_offset和大小p_filesz把整个&quot;解释器&quot;段的内容读入缓冲区</span></span><br><span class="line"><span class="built_in">kernel_read</span>(bprm-&gt;file, elf_ppnt-&gt;p_offset, elf_interpreter,elf_ppnt-&gt;p_filesz);</span><br><span class="line">          <span class="comment">//struct *file类型的interpreter指针指向解释器段</span></span><br><span class="line">interpreter = <span class="built_in">open_exec</span>(elf_interpreter);</span><br><span class="line">          <span class="comment">//读入其开头的128个字节，即解释器文件的elf头部。</span></span><br><span class="line">          <span class="built_in">kernel_read</span>(interpreter, <span class="number">0</span>, (<span class="type">void</span>*)&amp;loc-&gt;interp_elf_ex, <span class="built_in">sizeof</span>(loc-&gt;interp_elf_ex));</span><br><span class="line">          ...</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">elf_ppnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>3、清除前一个计算的所有资源，并分配新资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">flush_old_exec</span>(bprm);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">setup_new_exec</span>(bprm);</span><br></pre></td></tr></table></figure></li><li><p>4、设置栈段<br>检查所有的程序段，如果某一个段的类型为PT_GNU_STACK，即栈段，那么检查标志并设定相应的值，然后调用setup_arg_pages()函数利用do_execve()生成的参数页面的信息，来设定本程序$\verb+struct linux_binprm bprm+$的栈顶地址，然后mm-&gt;start_stack &#x3D; bprm-&gt;p,将mm的栈的起始地址设定为bprm中栈顶指针指向的位置。</p></li></ul><p>跳过中间一些处理器相关的检查操作，直接来到ELF段载入阶段</p><ul><li><p>5、加载目标程序必须的段，即将ELF文件中的映像载入内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>, elf_ppnt = elf_phdata; i &lt; loc-&gt;elf_ex.e_phnum; i++, elf_ppnt++) </span><br><span class="line">  &#123;</span><br><span class="line"><span class="type">int</span> elf_prot = <span class="number">0</span>, elf_flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> k, vaddr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> total_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//搜索PT_LOAD段，也就是需要加载的段，只有代码段和数据段需要装入</span></span><br><span class="line"><span class="keyword">if</span> (elf_ppnt-&gt;p_type != PT_LOAD)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//检查标志、页面信息</span></span><br><span class="line"><span class="keyword">if</span> (elf_ppnt-&gt;p_flags &amp; PF_R) elf_prot |= PROT_READ;</span><br><span class="line"><span class="keyword">if</span> (elf_ppnt-&gt;p_flags &amp; PF_W) elf_prot |= PROT_WRITE;</span><br><span class="line"><span class="keyword">if</span> (elf_ppnt-&gt;p_flags &amp; PF_X) elf_prot |= PROT_EXEC;</span><br><span class="line"></span><br><span class="line">vaddr = elf_ppnt-&gt;p_vaddr;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//设置e_flags标志</span></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      total_size = <span class="built_in">total_mapping_size</span>(elf_phdata, loc-&gt;elf_ex.e_phnum);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//通过elf_map()来将用户虚拟地址load + vaddr和文件映像中的区域映射</span></span><br><span class="line"><span class="built_in">elf_map</span>(bprm-&gt;file, load_bias + vaddr, elf_ppnt, elf_prot, elf_flags, total_size);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>遍历所有段，如果该段是可加载段（child程序的可加载段就是代码段和数据段），就确定装入内存的地址load_bias + vaddr，并通过elf_map()来建立用户虚拟地址和文件映像中的区域映射。这里的load_bias是随机生成的偏移量，在映射到进程的虚拟地址空间时，栈、堆、解析器段的起始地址往往加上一个随机偏移量。因为整个程序的虚拟起始地址固定为0x08048000，敏感的栈区域容易被算出地址，被黑客利用。elf_map利用vm_map来建立虚拟地址到文件映像的映射，与mmap类似。<br>mmap会将文件从交换空间加载进内存，并为进程新创建一个vm_area_struct，同时建立vm_area_struct与进程段的映射关系，例如代码段的vm_area_struct的vm_start字段表明代码起始地址为0x08048000，vm_end字段表明代码段的结束位置。现在代码段和数据段已经加载到内存中了。并且代码段和数据段的vm_area_struct也已经设置好了，插入了进程的mmap链表中：</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEBa5e38da11d4ff698e0aa0010fc73d156?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/> </li><li><p>6、接下来是填写程序的入口地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (elf_interpreter) </span><br><span class="line"> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> interp_map_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">elf_entry = <span class="built_in">load_elf_interp</span>(&amp;loc-&gt;interp_elf_ex, interpreter, </span><br><span class="line">               &amp;interp_map_addr, load_bias, interp_elf_phdata);</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> &#123;</span><br><span class="line">elf_entry = loc-&gt;elf_ex.e_entry;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果存在解释器段，就通过load_elf_interp()将其映像装入内存, 并把将来进入用户空间的入口地址elf_entry设置成解释器映像的入口地址，这样返回用户空间时先执行解析器程序，将需要的共享库(shared lib)映射到进程的虚拟地址空间中。如果没有解释器段，也就是child程序的情况，那么直接从ELF Header的e_entry字段获得程序入口地址（child文件映像的入口地址）。<br>此时入口地址应该是0x08048d0a!</p></li><li><p>7、执行前的准备<br>首先调用create_elf_tables()函数填写目标文件的命令行参数、环境变量等信息。这些信息需要复制到用户空间，使它们在PC跳转到解释器或目标映像的程序入口地址时出现在用户空间堆栈上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">create_elf_tables</span>(bprm, &amp;loc-&gt;elf_ex, load_addr, interp_load_addr);</span><br></pre></td></tr></table></figure><p>vm_area_struct线性区结构体的映射由mmap完成，现在完成mm_struct的初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> current-&gt;mm-&gt;end_code = end_code;</span><br><span class="line"> current-&gt;mm-&gt;start_code = start_code;</span><br><span class="line"> current-&gt;mm-&gt;start_data = start_data;</span><br><span class="line"> current-&gt;mm-&gt;end_data = end_data;</span><br><span class="line"> current-&gt;mm-&gt;start_stack = bprm-&gt;p;</span><br><span class="line"> <span class="keyword">if</span> ((current-&gt;flags &amp; PF_RANDOMIZE) &amp;&amp; (randomize_va_space &gt; <span class="number">1</span>)) </span><br><span class="line"> &#123;</span><br><span class="line">current-&gt;mm-&gt;brk = current-&gt;mm-&gt;start_brk = <span class="built_in">arch_randomize_brk</span>(current-&gt;mm);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>8、调用start_thread()函数准备执行此ELF程序<br>该函数是一个与体系结构相关的函数，在i386中其核心函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">regs-&gt;fs = <span class="number">0</span>;</span><br><span class="line">regs-&gt;ds = __USER_DS;</span><br><span class="line">regs-&gt;es = __USER_DS;</span><br><span class="line">regs-&gt;ss = __USER_DS;</span><br><span class="line">regs-&gt;cs = __USER_CS;</span><br><span class="line">regs-&gt;ip = new_ip;</span><br><span class="line">regs-&gt;sp = new_sp;</span><br><span class="line">regs-&gt;flags = X86_EFLAGS_IF;</span><br></pre></td></tr></table></figure><p>最后，函数跳转到regs-&gt;ip处(地址0x8048d0a)执行，execve系统调用结束。</p></li></ul><p>最终内存的情况如下图所示：</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEBaa532b54422051cd4217f2017b02d9ec?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/> <p>至此，程序的创建和可执行文件的加载过程全部结束！</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统内存管理</title>
      <link href="/2022/04/14/OS_Memory_Management/"/>
      <url>/2022/04/14/OS_Memory_Management/</url>
      
        <content type="html"><![CDATA[<h1 id="一、分页系统"><a href="#一、分页系统" class="headerlink" title="一、分页系统"></a>一、分页系统</h1><h2 id="1、段页式系统"><a href="#1、段页式系统" class="headerlink" title="1、段页式系统"></a>1、段页式系统</h2><p>段页式内存管理的模型中，逻辑地址（虚拟地址）先根据分段系统转换成线性地址，然后线性地址在分页系统中查询，Linux中弱化了分段机制，只在80x86处理器中使用分段。$Linux$采用了4级分页模型来适应多种硬件环境，但在80x86处理器中（IA-32架构）中使用二级分页模型，即页目录表和页表结合，将第2、3级页表整合进了页全局目录中。在64位体系结构中，2级页表不再适用，因此IA-64体系结构采用了3级页表，64位地址中39位（9+9+9+12）来寻址。</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB0d12a226c3f38c1f969af829e12275af?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="60%" height="60%"/>  <div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB93d72c4515da95343499f2207f959eb8?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="60%" height="60%"/>  <h2 id="2、自己做的页目录表和页表"><a href="#2、自己做的页目录表和页表" class="headerlink" title="2、自己做的页目录表和页表"></a>2、自己做的页目录表和页表</h2><p>这是我本科做实验时自己做的页目录和页表。其中用户程序使用$\verb+0x00<del>0xcfffffff+$这3GB逻辑地址空间，系统程序使用$\verb+0xc0000000</del>0xffffffff+$这1GB逻辑地址空间。在物理内存中，$\verb+0x00<del>0xfffff+$这1MB空间留给BIOS、MBR、Loader、中断向量表，页目录表位于内存$\verb+0x100000</del>0x100fff+$，大小共1KB，含1024个页目录项。页表紧跟着页目录表后面，页表0的地址为$\verb+0x101000<del>0x101fff+$，页表1的地址为$\verb+0x102000</del>0x102fff+$，依次类推。<br>页目录表中的第$\verb+0<del>767+$页目录项映射到低3GB逻辑内存中，而第$\verb+768</del>1022+$页目录项映射到高1GB逻辑内存中，1023号页目录项指向页目录表自己，而768号页目录项指向页表0，769号页目录项指向页表1，以此类推。页表0的第一个页表项指向地址$\verb+0x00+$为起始的4KB物理页（最上面的物理页0）。</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEBaa4e07bd5ea8a36a7fee1b719e45e1e8?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="60%" height="60%"/><p>注意所有用户的页目录表的$\verb+768<del>1022+$项完全相同，因为都指向共享的内核空间。创建进程时从页目录表的第$\verb+768</del>1022+$拷贝即可（图片中写错字了，应该是页目录表而不是页表）。</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEBeef4de30e9a491b8e5e67f7ac6a28611?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="60%" height="60%"/><h1 id="二、Linux内存管理"><a href="#二、Linux内存管理" class="headerlink" title="二、Linux内存管理"></a>二、Linux内存管理</h1><p>这里以一个用户程序$\verb+abc.c+$为例来探究Linux系统的内存管理策略。程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> bar[<span class="number">3968</span>]=<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> foo[<span class="number">4096</span>]=<span class="string">&quot;this is not a test\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">output_loop</span><span class="params">(<span class="type">char</span> * str)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line">    write(<span class="number">2</span>, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    sched_yield();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> pid1, pid2, status;</span><br><span class="line"></span><br><span class="line">  write(<span class="number">2</span>, foo, <span class="built_in">strlen</span>(foo));</span><br><span class="line">  <span class="built_in">strcpy</span>(foo, <span class="string">&quot;you are modified\n&quot;</span>);</span><br><span class="line">  write(<span class="number">2</span>, foo, <span class="built_in">strlen</span>(foo));</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (!(pid1 = fork()))&#123;</span><br><span class="line">    output_loop(<span class="string">&quot;B  &quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(pid2 = fork()))&#123;</span><br><span class="line">    output_loop(<span class="string">&quot;C  &quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output_loop(<span class="string">&quot;A  &quot;</span>);</span><br><span class="line">  waitpid(pid1, &amp;status, <span class="number">0</span>);</span><br><span class="line">  waitpid(pid2, &amp;status, <span class="number">0</span>);</span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1、进程地址空间"><a href="#1、进程地址空间" class="headerlink" title="1、进程地址空间"></a>1、进程地址空间</h2><p>abc程序的逻辑地址空间（右侧）如下图所示。其中用户程序使用$\verb+0x00-0xcfffffff+$这3GB逻辑地址空间，$\verb+abc+$程序的代码段为$\verb+0x08048000-0x080e8fff+$这161个页面，代码段为$\verb+0x080e9000-0x080ecfff+$这4个页面。数据段只包含$bar$和$foo$这两个变量对应的字符串，$bar$的地址为$\verb+0x080e9000+$，虽然只有3968个字节，但是也分配了2个页面（4096个字节），占用数据段中的第0、1个页面，$foo$的地址为$\verb+0x080eb000+$，占用数据段中的第2、3个页面。$\verb+task_struct+$为Linux的进程控制块PCB，里面包含指向内存控制块$\verb+mm_struct+$（所有内核进程的$\verb+mm_struct+$全部内容均为0）的指针。$\verb+mm_struct+$包含指向页目录表的指针$\verb+pgd+$以及指向$\verb+vm_area_struct+$线性区结构的指针$\verb+mmap+$，结构体$\verb+vm_area_struct+$描述的对应逻辑段的起始和结束逻辑地址等信息。所有$\verb+vm_area_struct+$组织成一棵红黑树。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB4e818deadc690a92531ae4b7dd59f4f9?method=download&shareKey=69113f8f61e335d1864757cf6d288929" alt="Linux分页系统以及abc程序的地址空间"><br>$foo$字符串的逻辑地址为$\verb+0x080eb000+$，高10位$\verb+0x20+$表示从页目录表的第$\verb+0x20+$项（对应的偏移为$\verb+0x80+$，一个页表项4个字节）取出页表地址，注意该处的$\verb+0x07518067+$的低12位为标志，不表示地址，页表的单位为4KB，故页表地址的低12位总是0。然后从$foo$字符串的中间10位$\verb+0xeb+$对应的偏移$\verb+0x3ac+$从页表中取出页帧的起始地址$\verb+0x065c6000+$，最后与$foo$字符串低12位页内偏移$\verb+0x000+$直接相加就可以得到$foo$字符串的物理地址。</p><h2 id="2、Linux的页描述符和页高速缓存"><a href="#2、Linux的页描述符和页高速缓存" class="headerlink" title="2、Linux的页描述符和页高速缓存"></a>2、Linux的页描述符和页高速缓存</h2><p>内存中的一个页称为页帧($page\ frame$)，一个页帧对应一个32字节的页描述符$\verb+struct page+$来描述，页帧描述符数组$\verb+struct page mem_map[]+$来描述所有的页帧，占整个内存空间的$\frac{32}{4096}&#x3D;\frac{1}{128}$。<br>为了更快速的读取文件，Linux在$\verb+abc+$程序刚开始运行时，数据段还没有被访问前就已经把文件中的数据段缓存入了内存中，但是页目录表和页表并没有内容指向这部分缓存，Linux只会在访问数据段中的变量时才会分配页目录项和页表项（这也叫做“请求调页”），缓存的页框称为页高速缓存。页高速缓存的每一个页框对应一个页描述符，页描述符用基树组织起来，如下图所示。</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB2ba0e77ad04bc1d9cac6fbc86f2116b9?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="60%" height="60%"/><p>本例中$\verb+abc+$程序的基树如下图所示：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB16b4d85145c8837036c4a41d3cfcc745?method=download&shareKey=69113f8f61e335d1864757cf6d288929"><br>图中数据段的页描述符的偏移为$\verb+0xa0+$，应该位于第2个基树叶子节点的第32个槽，该槽中的指针指向对应的$\verb+struct page+$，再指向对应的页帧缓存。  </p><h1 id="三、Linux缺页处理"><a href="#三、Linux缺页处理" class="headerlink" title="三、Linux缺页处理"></a>三、Linux缺页处理</h1><h2 id="1、缺页处理流程"><a href="#1、缺页处理流程" class="headerlink" title="1、缺页处理流程"></a>1、缺页处理流程</h2><p>这里以$\verb+abc+$程序中的三个函数来分析缺页处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">write(<span class="number">2</span>, foo, <span class="built_in">strlen</span>(foo));</span><br><span class="line"><span class="built_in">strcpy</span>(foo, <span class="string">&quot;you are modified\n&quot;</span>);</span><br><span class="line">write(<span class="number">2</span>, foo, <span class="built_in">strlen</span>(foo));</span><br></pre></td></tr></table></figure><h3 id="执行第一个write系统调用"><a href="#执行第一个write系统调用" class="headerlink" title="执行第一个write系统调用"></a>执行第一个write系统调用</h3><p>数据段包含$\verb+bar+$和$\verb+foo+$字符串，$\verb+foo+$字符串的起始地址为$\verb+0x080eb000+$，占2个页帧。程序执行到$\verb+write+$函数前一刻，数据段作为页高速缓存，缓存在了内存中，但是页目录项和页表项均为0，没有指向这个页缓存。程序在内核态往虚拟地址0x080ecf20(数据段第4页)写内容，（我也不知道写的是什么内容，可能是初始化的信息），发现页目录项为0。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB71a5c80affeec83e41ff2c5e05c29bbd?method=download&shareKey=69113f8f61e335d1864757cf6d288929" alt="第一次缺页时的初始状态"><br>此时引发缺页异常，执行$\verb+__do_page_fault+$缺页处理函数，执行$\verb+do_cow_fault+$写时复制，修改页目录项，但页表项仍然全0，再从$\verb+0x065c9000+$拷贝数据到另一片内存$\verb+0x01b35000+$中，并修改第4个页表项为$\verb+0x01b35067+$(最低位为7表示该页面可写)，指向拷贝的内存。最后回到引发缺页的指令，重启该指令往逻辑地址$\verb+0x080e9fc4+$（也就是物理地址$\verb+0x01b35000+$处）写内容。<br>注意，页表项不能直接指向页缓存$\verb+0x065d1000+$处并向该地址写内容，必须先拷贝内容到另一块内存中，否则页缓存$\verb+0x065d1000+$成为脏页面，脏页面的内容会写回磁盘中，从而引起磁盘上程序内容的改变。<br><img src="https://note.youdao.com/yws/api/personal/file/WEBc26ad4fdc414d7430d64c730752ee683?method=download&shareKey=69113f8f61e335d1864757cf6d288929" alt="第一次缺页处理"><br>然后程序在用户态往$\verb+0x080e9fc4+$(数据段第1页)写内容，发现页帧不存在，开始缺页处理，执行$\verb+do_cow_fault+$函数，从$\verb+0x065c6000+$拷贝数据到另一片内存中$\verb+0x01b34000+$，并修改第一个页表项指向拷贝的内存。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB66fe4e1cdb31a275d66e865d022732bf?method=download&shareKey=69113f8f61e335d1864757cf6d288929" alt="第二次缺页处理"><br>随后是第3次缺页异常，在用户态往$\verb+0x80ea040+$(数据段第2页)读内容，发现页帧不存在，引发缺页处理，执行$\verb+do_read_fault+$函数，因为只是读该页面，不需要写页面，所以修改第2、3个页表项指向第2、3个页帧缓存$\verb+0x065cf000+$和$\verb+0x065d0000+$即可，页表项的最低4位为5表示该页面只读。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB8faa3a5ed4916f2e7e69871238033cff?method=download&shareKey=69113f8f61e335d1864757cf6d288929"><br>之后是第4次缺页异常，程序在用户态往$\verb+0x80ea040+$(数据段第2页)写内容，发现该页面只读，执行$\verb+do_wp_page+$函数，从第2个页表项指向的$\verb+0x065cf000+$拷贝内容到新的内存地址$\verb+0x07d85000+$并修改页表项指向拷贝的新页帧。我发现程序往这个地址写的竟然是空字符串””。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB5c7b6dc7cb9a07568443d4d5a5bb82a9?method=download&shareKey=69113f8f61e335d1864757cf6d288929"><br>此时程序刚刚进入$main$函数，然后终端打印$\verb+foo+$字符串，$\verb+write+$结束。全局的视角看起来应该是这样：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB26fa4947c1e7e03f31b54dddae8be1a9?method=download&shareKey=69113f8f61e335d1864757cf6d288929"></p><h3 id="执行strcpy函数"><a href="#执行strcpy函数" class="headerlink" title="执行strcpy函数"></a>执行strcpy函数</h3><p>$\verb+strcpy+$函数将$\verb+foo+$字符串的内容改写成”you are modified.”。此时$\verb+foo+$字符串所在的地址为第3个页表项指向的页面缓存。在用户态往$\verb+0x80eb000+$(第3页，即foo字符串地址)写内容，发现该页面只读，执行$\verb+do_wp_page+$函数，从第3个页表项指向的$\verb+foo+$字符串地址$\verb+0x065d0000+$拷贝字符串到内存$0x01b3a000$处并修改页表项指向新拷贝的内存地址，再往新的页帧写字符串$\verb+”you are modified”+$。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB3f2c9510c2c066da94bf25f657684598?method=download&shareKey=69113f8f61e335d1864757cf6d288929"><br>$\verb+strcpy+$函数结束时4个页表项都将最低为从7改为5，此时页面只读，不可写，然后$\verb+strcpy+$结束，执行$\verb+write+$函数，打印新的字符串。<br><img src="https://note.youdao.com/yws/api/personal/file/WEBe288d6203e8207ba7782b958abb5ffbe?method=download&shareKey=69113f8f61e335d1864757cf6d288929"></p><h2 id="2、回写脏页面"><a href="#2、回写脏页面" class="headerlink" title="2、回写脏页面"></a>2、回写脏页面</h2><p>若在执行$\verb+strcpy+$函数之前，把第3个页表项标志位改为7结尾，页面变为可写，在执行$\verb+strcpy+$函数时，新字符串的将会被写入第3个页表项指向的$\verb+foo+$字符串地址$\verb+0x065d0000+$中，该页帧成为脏页面，回写到磁盘上，磁盘上的程序内容也会被更改，下次执行abc程序时直接输出新字符串。<br><img src="https://note.youdao.com/yws/api/personal/file/WEBd1510963910d7d4323be7e44608a5c7b?method=download&shareKey=69113f8f61e335d1864757cf6d288929"><br>下次执行程序时的结果：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB3a05bb03ae842bdefed44e3e9abd9af8?method=download&shareKey=69113f8f61e335d1864757cf6d288929"><br>两次打印的都是修改后的字符串。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统启动过程简述</title>
      <link href="/2022/04/10/OS_Starting/"/>
      <url>/2022/04/10/OS_Starting/</url>
      
        <content type="html"><![CDATA[<h1 id="一、操作系统启动生成的进程树"><a href="#一、操作系统启动生成的进程树" class="headerlink" title="一、操作系统启动生成的进程树"></a>一、操作系统启动生成的进程树</h1><p>下图是我在做实验时调试出来的操作系统生成的进程树，计算机在刚开始启动时执行的是汇编代码，然后执行的第一行C代码是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_kernel</span><br></pre></td></tr></table></figure><p>在执行这个函数之后，正在执行的程序成为0号进程，0号进程会先后调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__do_fork</span><br><span class="line">do_execve</span><br></pre></td></tr></table></figure><p>两个函数去执行$\verb+fork+$和$\verb+exec+$两个系统调用，生成1号和2号进程，1号进程就是大名鼎鼎的$init$进程，所有用户程序的根进程（包括$shell$进程和用户登录进程等等）。2号进程负责创建和维护所有内核线程（在本图中是960号及之前的进程）。最后0号进程调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpu_dile</span><br></pre></td></tr></table></figure><p>函数进入休眠状态，CPU在没有活跃任务可调度时就执行它。<br><img src="https://note.youdao.com/yws/api/personal/file/WEBaa78b81deaec02c397484e8a2a5b43d4?method=download&shareKey=69113f8f61e335d1864757cf6d288929" alt="操作系统启动时生成的进程树"></p><h1 id="二、计算机启动过程"><a href="#二、计算机启动过程" class="headerlink" title="二、计算机启动过程"></a>二、计算机启动过程</h1><p>本科做实验时画的图，描绘的时MBR启动的图，计算机先执行BIOS，然后跳转到$\verb+0x7c00+$地址执行MBR，然后执行Loader，完成实模式向保护模式切换、页表初始化等工作，然后进入内核。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB06869dacb48da066cbcdabfb88241216?method=download&shareKey=69113f8f61e335d1864757cf6d288929" alt="MBR启动过程"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>First Allreduce Application</title>
      <link href="/2022/03/30/First_MPI_Program/"/>
      <url>/2022/03/30/First_MPI_Program/</url>
      
        <content type="html"><![CDATA[<h1 id="MPI安装"><a href="#MPI安装" class="headerlink" title="MPI安装"></a>MPI安装</h1><h2 id="Linux安装MPICH"><a href="#Linux安装MPICH" class="headerlink" title="Linux安装MPICH"></a>Linux安装MPICH</h2><p>$MPICH$是$MPI$的一个使用的非常广泛的库。简单的在$linux$中$sudo\ apt-get\ install$就可以安装成功，当然也可以下载$MPICH$源码，可参考<a href="https://mpitutorial.com/tutorials/installing-mpich2/zh_cn/">MPICH安装</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install mpich</span><br></pre></td></tr></table></figure><p>通过在程序中添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mpi.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>即可调用$MPICH$，可以参考<a href="https://mpitutorial.com/tutorials/mpi-hello-world/zh_cn/">这里</a>写第一个简单的$MPI\ Hello\ World$程序。<br>$mpicc$和$mpicxx$是$MPICH$的编译器，看名字就知道分别对应$C$和$C++$程序。简单使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpicc helloworld.c -o helloworld</span><br></pre></td></tr></table></figure><p>就可以编译程序，再使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpirun -n <span class="number">4</span> helloworld</span><br></pre></td></tr></table></figure><p>就可以运行$mpi$程序，$mpiexec$和$mpirun$是$MPICH$提供的两个解释器，能够运行我们编写的应用程序，其中$mpirun$只能使每个进程运行同一个程序，而$mpiexec$能使不同进程运行不同的程序，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpiexec -n <span class="number">1</span> program1 : -n <span class="number">2</span> porgram2</span><br></pre></td></tr></table></figure><h1 id="Windows安装MPI"><a href="#Windows安装MPI" class="headerlink" title="Windows安装MPI"></a>Windows安装MPI</h1><h2 id="下载MPICH"><a href="#下载MPICH" class="headerlink" title="下载MPICH"></a>下载MPICH</h2><p>在<a href="https://www.mpich.org/downloads/">MPICH官网</a>下载源码包，选择$Windows$系统，然后在这里点击$http$。<img src="https://note.youdao.com/yws/api/personal/file/WEB20896ad49caab7166ef314cad41a02b6?method=download&shareKey=904f976c5859bc89c59dc0453602ff98"><br>再选择这里的安装：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB7c6b5b95675ec4f841346e261f69ce27?method=download&shareKey=707ee3c6204b8e72dfaa8e511c794021"><br>把两个安装程序都装上：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB6d1c0e875e7a9f657caabefebba78720?method=download&shareKey=707ee3c6204b8e72dfaa8e511c794021"><br>分别点击两个安装程序，生成如下两个文件夹（可以放在D盘，自己命名文件夹）:<br><img src="https://note.youdao.com/yws/api/personal/file/WEBf74acea7bf53fffaa844e63a7dec88c0?method=download&shareKey=707ee3c6204b8e72dfaa8e511c794021"></p><h2 id="在Visual-Studio中配置环境"><a href="#在Visual-Studio中配置环境" class="headerlink" title="在Visual Studio中配置环境"></a>在Visual Studio中配置环境</h2><p>在$Visual Studio$中“创建新项目”-&gt;“控制台应用”。我得项目名字叫“MPITest”，然后选择“调试”-&gt;“调试属性”。<br><img src="https://note.youdao.com/yws/api/personal/file/WEBe948b4c6c4177ceb858b5b701b2c30d5?method=download&shareKey=707ee3c6204b8e72dfaa8e511c794021"><br>选择“C&#x2F;C++”-&gt;“预处理器”-&gt;“预处理器定义”-&gt;添加“MPICH_SKIP_MPICXX”<br><img src="https://note.youdao.com/yws/api/personal/file/WEB20c39cee8383c7ff5aa58051b1813587?method=download&shareKey=707ee3c6204b8e72dfaa8e511c794021"><br>选择“代码生成”-&gt;“运行库”-&gt;“多线程调试\MTD”：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB3649df78f08d5e177074bb94203e796c?method=download&shareKey=707ee3c6204b8e72dfaa8e511c794021"><br>选择“输入”-&gt;“添加附加依赖项”-&gt;添加“msmpi.lib”<br><img src="https://note.youdao.com/yws/api/personal/file/WEB40a3f1b4bf58bf1355913ab011d39dba?method=download&shareKey=707ee3c6204b8e72dfaa8e511c794021"><br>选择“VC++目录”-&gt;“包含目录”-&gt;添加“(MPI安装位置)\Microsoft SDKs\Include”；<br><img src="https://note.youdao.com/yws/api/personal/file/WEB45e6a730d39c84744f498943cede91f3?method=download&shareKey=707ee3c6204b8e72dfaa8e511c794021"><br>再选择“库目录”-&gt;添加“(MPI安装位置)\Microsoft SDKs\Lib\x64”<br><img src="https://note.youdao.com/yws/api/personal/file/WEBb24da11e6a4661787def0934cdfbe1fd?method=download&shareKey=707ee3c6204b8e72dfaa8e511c794021"><br>配置完成。</p><h2 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h2><h3 id="使用cmd终端或者Powershell终端运行"><a href="#使用cmd终端或者Powershell终端运行" class="headerlink" title="使用cmd终端或者Powershell终端运行"></a>使用cmd终端或者Powershell终端运行</h3><p>按照下一节的$Allreduce$积分程序写好代码，然后$VS$里点击运行，生成$.exe$文件，由于$VS$的默认进程数是1，只能运行进程数为1的情况。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB45f2da6f8a6933d86356422c763a9d35?method=download&shareKey=707ee3c6204b8e72dfaa8e511c794021"><br>打开cmd终端，在$.exe$文件的目录下输入指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpiexec -n <span class="number">4</span> MPITest.exe</span><br></pre></td></tr></table></figure><p>得到结果:<br><img src="https://note.youdao.com/yws/api/personal/file/WEB2a2c779942cc9145ed1cb903c51aa7e3?method=download&shareKey=707ee3c6204b8e72dfaa8e511c794021"></p><h3 id="在VS里配置命令"><a href="#在VS里配置命令" class="headerlink" title="在VS里配置命令"></a>在VS里配置命令</h3><p>复制$MPITest.exe$程序到$C$盘，然后点击“MPITest项目属性”-&gt;“调试”，配置命令行属性如图即可。注意命令参数是“mpiexec.exe”程序所在的文件夹，在最开始生成的两个安装文件包的“Microsoft MPI”里，并且$MPITest.exe$程序一定要拷贝到$C$盘！！！不然$VS$会报错找不到这个$MPITest.exe$程序，不知道为什么会有这个$bug$。<br><img src="https://note.youdao.com/yws/api/personal/file/WEBf9d84e95565cd0cf872f810f043ea6ed?method=download&shareKey=707ee3c6204b8e72dfaa8e511c794021"></p><h1 id="First-Allreduce-Program"><a href="#First-Allreduce-Program" class="headerlink" title="First Allreduce Program"></a>First Allreduce Program</h1><p>这里展示调用$MPI$_ $Allreduce$函数来使用梯形积分法求解$\int_{1}^{e}\ln{x}dx$。<br>$Allreduce$操作是$MPI$中最常用的集合通信操作，与之相似的是$Reduce$操作，假设有$p$个进程，每个进程都持有一个含$n$个元素的向量，所有的$p$个进程将自己的向量发送给根进程，根进程收集这些向量计算规约的结果（求和、求最大最小值等等），$Reduce$操作结果保存在根进程，$Allreduce$则将根进程的结果再广播出去。简单的在应用程序中调用$MPI$_$Allreduce$就可以完成上述例程，函数定义如下：<br>程序可以表示为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Allreduce</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> <span class="type">void</span> *sendbuf,      <span class="comment">//存放源数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">void</span> *recvbuf,            <span class="comment">//存放规约结果</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> count,                <span class="comment">//数据个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">            MPI_Datatype datatype,    <span class="comment">//数据类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">            MPI_Op op,                <span class="comment">//规约操作类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">            MPI_Comm comm)</span></span>;           <span class="comment">//一组通信进程</span></span><br></pre></td></tr></table></figure><p>$MPI$<em>$Reduce$ 和$MPI$</em>$Allreduce$例程的图解如下所示：</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB635e35297acaeac7ad5f79fc97142fab?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB8453078f33cba2dcd2ba5b49d8b04daf?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div><p>图片源网址和$MPI$_$Allreduce$的入门教程在这里：<a href="https://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/">英文版</a>和<a href="https://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/zh_cn/">中文版</a> </p><p>利用梯形积分法求解$\int_{1}^{e}\ln{x}dx$的思路是将区间$[1,e]$分成1024个段，一个段对应一个狭小的梯形，面积为$\ln{x_i}\cdot{dx}$，然后将这些梯形相加。$MPI$可以创建多个进程来加速，每个进程计算一部分区间的积分，然后将结果相加起来。在程序中$a$和$b$是整个积分的区间，$local$_ $a$和$local$_$b$是每个进程负责的区间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   eexp(1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  n = <span class="number">1024</span>, local_n;</span><br><span class="line"><span class="type">double</span>  a = <span class="number">1.0</span>, b = e, len;</span><br><span class="line"><span class="type">double</span>  local_a, local_b, sum = <span class="number">0.0</span>, ans, local_ans;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>  <span class="title function_">calc</span><span class="params">(<span class="type">double</span>  local_a, <span class="type">double</span>  local_b, <span class="type">int</span>  local_n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> sum = (<span class="built_in">log</span>(local_a) + <span class="built_in">log</span>(local_b)) / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> xi;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; local_n; i++)</span><br><span class="line">&#123;</span><br><span class="line">xi = local_a + len * i;</span><br><span class="line">sum += <span class="built_in">fabs</span>(<span class="built_in">log</span>(xi));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  sum * len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  comm_size;</span><br><span class="line"><span class="type">int</span>  my_rank;</span><br><span class="line">MPI_Init(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">MPI_Comm_size(MPI_COMM_WORLD, &amp;comm_size);</span><br><span class="line">MPI_Comm_rank(MPI_COMM_WORLD, &amp;my_rank);</span><br><span class="line"></span><br><span class="line">len = (b - a) / n;<span class="comment">//就是dx</span></span><br><span class="line">local_a = a + my_rank * len * (n / comm_size);<span class="comment">//local_a是每个进程负责计算的区间的起始</span></span><br><span class="line">local_b = local_a + len * (n / comm_size);<span class="comment">//local_b是每个进程负责计算的区间的结束</span></span><br><span class="line">local_n = n / comm_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个进程计算自己区间上的积分</span></span><br><span class="line">local_ans = calc(local_a, local_b, local_n);</span><br><span class="line"><span class="comment">//每个进程计算的结果local_ans相加到全局结果ans上</span></span><br><span class="line">MPI_Allreduce(&amp;local_ans, &amp;ans, <span class="number">1</span>, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My rank: %d, Result : %.5f\n&quot;</span>, my_rank, ans);</span><br><span class="line">MPI_Finalize();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在$Linux$中编译时链接上$lm$数学运算库：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mpicc allreduce.c -o allreduce -lm</span><br><span class="line">mpiexec -n <span class="number">4</span> allreduce</span><br></pre></td></tr></table></figure><p>即可得到结果。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
          <category> 并行计算 </category>
          
          <category> 并行程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MPI </tag>
            
            <tag> 并行计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MPI_Allreduce的前世今生</title>
      <link href="/2022/03/27/MPI_Allreduce_Summary/"/>
      <url>/2022/03/27/MPI_Allreduce_Summary/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文介绍<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="9.624ex" height="1.645ex" role="img" focusable="false" viewBox="0 -716 4254 727" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path><path id="MJX-1-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path><path id="MJX-1-TEX-I-1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-I-1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path><path id="MJX-1-TEX-I-1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path><path id="MJX-1-TEX-I-1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-I-1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-1-TEX-I-1D434"></use></g><g data-mml-node="mi" transform="translate(750,0)"><use data-c="1D459" xlink:href="#MJX-1-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(1048,0)"><use data-c="1D459" xlink:href="#MJX-1-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(1346,0)"><use data-c="1D45F" xlink:href="#MJX-1-TEX-I-1D45F"></use></g><g data-mml-node="mi" transform="translate(1797,0)"><use data-c="1D452" xlink:href="#MJX-1-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(2263,0)"><use data-c="1D451" xlink:href="#MJX-1-TEX-I-1D451"></use></g><g data-mml-node="mi" transform="translate(2783,0)"><use data-c="1D462" xlink:href="#MJX-1-TEX-I-1D462"></use></g><g data-mml-node="mi" transform="translate(3355,0)"><use data-c="1D450" xlink:href="#MJX-1-TEX-I-1D450"></use></g><g data-mml-node="mi" transform="translate(3788,0)"><use data-c="1D452" xlink:href="#MJX-1-TEX-I-1D452"></use></g></g></g></svg></mjx-container>操作在$MPI$中的算法设计和实现，归纳和整理其发展脉络，追溯到最新的研究进展，并分析$MPI$的典型实现$MPICH$库中是怎样实现$Allreduce$例程的。</p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.107ex;" xmlns="http://www.w3.org/2000/svg" width="25.373ex" height="3.064ex" role="img" focusable="false" viewBox="0 -864.9 11214.8 1354.2" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path><path id="MJX-1-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D714" d="M495 384Q495 406 514 424T555 443Q574 443 589 425T604 364Q604 334 592 278T555 155T483 38T377 -11Q297 -11 267 66Q266 68 260 61Q201 -11 125 -11Q15 -11 15 139Q15 230 56 325T123 434Q135 441 147 436Q160 429 160 418Q160 406 140 379T94 306T62 208Q61 202 61 187Q61 124 85 100T143 76Q201 76 245 129L253 137V156Q258 297 317 297Q348 297 348 261Q348 243 338 213T318 158L308 135Q309 133 310 129T318 115T334 97T358 83T393 76Q456 76 501 148T546 274Q546 305 533 325T508 357T495 384Z"></path><path id="MJX-1-TEX-I-1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-1-TEX-I-1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path><path id="MJX-1-TEX-I-1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path><path id="MJX-1-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D460" xlink:href="#MJX-1-TEX-I-1D460"></use></g><g data-mml-node="mi" transform="translate(469,0)"><use data-c="1D456" xlink:href="#MJX-1-TEX-I-1D456"></use></g><g data-mml-node="mi" transform="translate(814,0)"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(1414,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1803,0)"><use data-c="1D714" xlink:href="#MJX-1-TEX-I-1D714"></use></g><g data-mml-node="mi" transform="translate(2425,0)"><use data-c="1D461" xlink:href="#MJX-1-TEX-I-1D461"></use></g><g data-mml-node="mo" transform="translate(2786,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(3452.8,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mfrac" transform="translate(4508.6,0)"><g data-mml-node="mn" transform="translate(365.7,394) scale(0.707)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g><g data-mml-node="mrow" transform="translate(220,-345) scale(0.707)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(500,0)"><use data-c="1D457" xlink:href="#MJX-1-TEX-I-1D457"></use></g></g><rect width="844.9" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(5593.4,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="msup" transform="translate(5982.4,0)"><g data-mml-node="mi"><use data-c="1D452" xlink:href="#MJX-1-TEX-I-1D452"></use></g><g data-mml-node="TeXAtom" transform="translate(499,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D457" xlink:href="#MJX-1-TEX-I-1D457"></use></g><g data-mml-node="mi" transform="translate(412,0)"><use data-c="1D714" xlink:href="#MJX-1-TEX-I-1D714"></use></g><g data-mml-node="mi" transform="translate(1034,0)"><use data-c="1D461" xlink:href="#MJX-1-TEX-I-1D461"></use></g></g></g><g data-mml-node="mo" transform="translate(7740.1,0)"><use data-c="2212" xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="msup" transform="translate(8740.3,0)"><g data-mml-node="mi"><use data-c="1D452" xlink:href="#MJX-1-TEX-I-1D452"></use></g><g data-mml-node="TeXAtom" transform="translate(499,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><use data-c="2212" xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(778,0)"><use data-c="1D457" xlink:href="#MJX-1-TEX-I-1D457"></use></g><g data-mml-node="mi" transform="translate(1190,0)"><use data-c="1D714" xlink:href="#MJX-1-TEX-I-1D714"></use></g><g data-mml-node="mi" transform="translate(1812,0)"><use data-c="1D461" xlink:href="#MJX-1-TEX-I-1D461"></use></g></g></g><g data-mml-node="mo" transform="translate(10825.8,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container><h1 id="Allreduce介绍"><a href="#Allreduce介绍" class="headerlink" title="Allreduce介绍"></a>Allreduce介绍</h1><p>$Allreduce$操作是$MPI$中最常用的集合通信操作，与之相似的是$Reduce$操作，假设有$p$个进程，每个进程都持有一个含$n$个元素的向量，所有的$p$个进程将自己的向量发送给根进程，根进程收集这些向量计算规约的结果（求和、求最大最小值等等），$Reduce$操作结果保存在根进程，$Allreduce$则将根进程的结果再广播出去。简单的在应用程序中调用$\verb+MPI_Allreduce+$就可以完成上述例程，函数定义如下：<br>程序可以表示为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Allreduce</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> <span class="type">void</span> *sendbuf,      <span class="comment">//存放源数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">void</span> *recvbuf,            <span class="comment">//存放规约结果</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> count,                <span class="comment">//数据个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">            MPI_Datatype datatype,    <span class="comment">//数据类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">            MPI_Op op,                <span class="comment">//规约操作类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">            MPI_Comm comm)</span></span>;           <span class="comment">//一组通信进程</span></span><br></pre></td></tr></table></figure><p>$\verb+MPI_Reduce+$和$\verb+MPI_Allreduce+$例程的图解如下所示：</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB635e35297acaeac7ad5f79fc97142fab?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB8453078f33cba2dcd2ba5b49d8b04daf?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div><p>图片源网址和$\verb+MPI_Allreduce+$的入门教程在这里：<a href="https://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/">英文版</a>和<a href="https://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/zh_cn/">中文版</a>  </p><p>$\verb+MPI_Allreduce+$广泛用于各种并行与分布式应用程序：科学计算、大数据、分布式机器学习、分布式深度学习DNN等等，并且<a href="https://ieeexplore.ieee.org/document/8665758">已有工作</a>表明$\verb+MPI_Allreduce+$是使用频率和运行时间最长的集合通信操作。</p><p>自从$MPI$标准在$1994$年提出以来，$\verb+MPI_Allreduce+$的相关研究从上世纪90年代就已经有很多了，而本文从2005年的一篇综述论文出发，一直追溯到现在，总结$\verb+MPI_Allreduce+$的算法激情燃烧的昨天、老骥伏枥的今天和仰望星空过后的明天。  </p><h1 id="经典数据结构与算法"><a href="#经典数据结构与算法" class="headerlink" title="经典数据结构与算法"></a>经典数据结构与算法</h1><h2 id="0、评估模型：-T-x3D-alpha-n-beta"><a href="#0、评估模型：-T-x3D-alpha-n-beta" class="headerlink" title="0、评估模型：$T&#x3D;\alpha+n\beta$"></a>0、评估模型：$T&#x3D;\alpha+n\beta$</h2><p><a href="https://journals.sagepub.com/doi/10.1177/1094342005051521">2005:Optimization of Collective Communication Operations in MPICH</a>是一篇经典的$MPI$集合通信论文，介绍了常用的集合通信操作和对应的算法：$\verb+Allgather+$, $\verb+Broadcast+$, $\verb+All-to-all+$, $\verb+Reduce-Scatter+$, $\verb+Reduce+$和$\verb+Allreduce+$，并进一步的讨论了$\verb+MPI_Reduce+$和$\verb+MPI_Allreduce+$的优化。我有一门选修课的作业就是将这篇论文全文翻译：<a href="https://note.youdao.com/ynoteshare/index.html?id=1b5cc29dea0aff44f92bdb69a2763e79&type=notebook&_time=1648432853246#/WEB26278ae64dfc1a52e0ece0dd615075f3">翻译原文</a>。<br>这篇文章采用的性能评估模型是$T&#x3D;\alpha+n\beta$，任意两个节点之间发送一条消息的时间可以用$T&#x3D;\alpha+n\beta$，其中$\alpha$表示延迟（或者说启动时间），与消息大小无关，而$\beta$表示每个字节的传输时间，$n$表示传输消息的字节数，对于规约操作则用$\gamma$表示每个字节执行规约操作的时间消耗。由于$MPI$基于分布式存储系统，采用$LogP$模型（$L:latency$, $o:overhead$, $g:gap$, $P:processor$），一条长度为$n$的消息传输时间可以计算为:<br>$$T&#x3D;L+2o+(n-1)b,其中b&#x3D;min(o, g)$$<br>也就是传输延迟$L$加上两端处理器的处理开销$2o$，和$n$个字节的传输时间，注意$overhead$是任意一个消息的处理开销，$gap$是连续两个字节的传输时间间隔。将上述式子变形，可以得到：<br>$$T&#x3D;(L+2o-b)+nb&#x3D;\alpha+n\beta$$<br>这也就是本文性能评估模型的公式，许多文献和教材中也用到了这个公式。我们将$\alpha$称为延迟项$(latency\ term)$，而$n\beta$称为带宽项$(bandwidth\ term)$，并用这个公式来形式化的评估集合通信算法的性能。<br>下面深入讨论这篇论文介绍的集合通信算法。  </p><h2 id="1、-Allgather-操作及算法"><a href="#1、-Allgather-操作及算法" class="headerlink" title="1、$Allgather$操作及算法"></a>1、$Allgather$操作及算法</h2><p>$Allgather$操作的图解如下:  </p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB5c825f77e456600e07ef80d2b87f1e17?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13"/></div>  <p>$\verb+MPI_Allgather+$函数可以参考<a href="https://mpitutorial.com/tutorials/mpi-scatter-gather-and-allgather/">MPI_Allgather</a>。 </p><h3 id="Ring-Algorithm"><a href="#Ring-Algorithm" class="headerlink" title="Ring Algorithm"></a>Ring Algorithm</h3><p>$MPICH$中最初实现$Allgather$操作使用的就是$Ring$算法。</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEBb157d10d3be479fb109ae83144da86e9?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="40%" height="40%"/></div> <p>每一个进程$i$发送本地数据给进程$(i+1)%p$，并且接受来自$(i-1)%p$的数据（环绕方式）。以后每一步，进程$i$都向进程$(i+1)%p$发送上一步接收的来自$(i-1)%p$号进程的数据。假设有$p$个进程，该算法总共需要$p-1$步来完成。用$n$表示收集的数据总量，每一步每个进程都发送$\frac{n}{p}$的数据，因此算法的时间消耗可以计算为：<br>$$T_{Ring}&#x3D;(p-1)\alpha+\frac{p-1}{p}n\beta$$    </p><h3 id="Recursive-Doubling"><a href="#Recursive-Doubling" class="headerlink" title="Recursive Doubling"></a>Recursive Doubling</h3><p>递归加倍算法的流程如下图所示：</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB0cedb39776a1eb420c04698b214a371e?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="50%" height="50%"/></div> <p>在第一步，彼此间距离为1的进程之间互相交换数据，数据量为$\frac{n}{p}$；第二步，彼此间距离为2的进程之间交换进程自己以及上一步从邻居进程接受的数据，数据量为$\frac{2n}{p}$；在第三步，彼此间距离为4的进程之间交换进程自己以及前两步从其他进程接受的数据，数据量为$\frac{4n}{p}$，以此类推，所有进程会在$lgP$步获得所有数据，执行时间为：<br>$$T_{rec_dbl}&#x3D;lgP\cdot\alpha+\frac{p-1}{p}n\beta$$<br>其中带宽项和环算法相同，这是因为：<br>$$\frac{n}{p}\beta+\frac{2n}{p}\beta+…+\frac{2^{lgP-1}n}{p}\beta&#x3D;\frac{p-1}{p}n\beta$$<br>这个等式的内在逻辑是任意一个进程总要接受来自其他$p-1$进程发送的总共$(p-1)\cdot\frac{n}{p}$数据量，也就是说带宽项是不能进一步减少的，但是延迟项可以通过优化算法来减少。递归加倍算法能很好的处理进程数量为2的整数幂的情况，但较难处理进程数量非2的幂次的情况。 </p><h3 id="Bruck-Algorithm"><a href="#Bruck-Algorithm" class="headerlink" title="Bruck Algorithm"></a>Bruck Algorithm</h3><p>$Bruck$算法能够很好的处理进程数非2的幂次的情况，算法的执行步骤为$\lceil{lgP}\rceil$步，算法图解如下所示</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEBe58d78d1a74b305f1da143695784f911?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13"/></div> <p>每个进程都有一片大小为$n$的缓存存放数据，在算法的开始，每个进程将本地数据拷贝到缓存的顶部。在第$k$步，进程$i$向目标进程$(i-2^k)%p$发送本地的所有数据，并将接受的数据（来自进程$(i+2^k)%p$）添加至本地数据的末尾，一共$\lfloor{lgP}\rfloor$步。如果进程的数量不是2的幂，还需要额外的一步，每个进程向目标进程$(i-2^k)%p$发送自己缓存头部的$p-2^{\lfloor{lgP}\rfloor}$块数据（前面步骤都是本地全部数据，这里是头部的部分数据），并将接受的数据添加到本地缓存末尾。<br>现在，所有进程都已经获得了全部数据，但是数据并不是以正确的顺序排列在缓存中：进程$i$中的所有数据块都向上偏移了$i$块。因此简单的将所有数据块循环向下移动$i$块就能将数据块调整到正确的位置上。算法的时间开销为：<br>$$T_{Bruck}&#x3D;\lceil{lgP}\rceil\cdot\alpha+\frac{p-1}{p}n\beta$$<br>$Allgather$操作的算法选取策略是：</p><ul><li>当进程数量为2的幂并且发送短消息或者中等规模消息，采用$Recursive\ doubling$算法；</li><li>当发送短消息以及进程数量非2的幂的情况下，采用$Bruck$算法；</li><li>发送大消息，无论进程数量是多少，并且进程数量非2幂且发送中等规模消息，采用$Ring$算法。</li></ul><h2 id="2、-Broadcast-操作及算法"><a href="#2、-Broadcast-操作及算法" class="headerlink" title="2、$Broadcast$操作及算法"></a>2、$Broadcast$操作及算法</h2><p>广播操作由根进程将根进程中的数据广播给所有进程，对应的是$\verb+MPI_Bcast+$函数，可以参考<a href="https://mpitutorial.com/tutorials/mpi-broadcast-and-collective-communication/">MPI_Bcast</a></p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEBa1d3f66081e6d3666838b6ff37186727?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13"/></div> <h3 id="Bionomial-Tree"><a href="#Bionomial-Tree" class="headerlink" title="Bionomial Tree"></a>Bionomial Tree</h3><p>$MPICH$中广播操作最初使用二项树算法。在第一步，根进程$root$向目标进程$(root+\frac{p}{2})%p$发送数据，进程$(root+\frac{p}{2})%p$以及根进程成为它们子树的根结点，继续递归执行算法。该算法一共执行$\lceil{\lg{p}}\rceil$步，在每一步所有进程发送的数据量均为$n$，因此算法的时间开销为：<br>$$T_{tree}&#x3D;\lceil{\lg{p}}\rceil\cdot(\alpha+n\beta)$$</p><h3 id="Scatter-Allgather"><a href="#Scatter-Allgather" class="headerlink" title="Scatter + Allgather"></a>Scatter + Allgather</h3><p>这是一种组合算法，又叫$Van\ de\ Geijn$算法，将$Scatter$和$Allgather$两个操作组合成了$Broadcast$操作。$Scatter$（散播）操作与$Broadcast$操作的对比如下:</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEBc635d7af2913d2a188bcd426165b25b5?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13"/></div> <p>在该算法中，要广播的数据先分成若干份，散播到各个进程中，接着，散播的数据又收集到所有进程中，也就是再执行$\verb+MPI_Allgather+$操作。其中Scatter操作使用二项树算法，时间消耗为：<br>$$T_{Scatter}&#x3D;\lg{p}\cdot\alpha+\frac{p-1}{p}n\beta$$<br>时间消耗和$Allgather$递归加倍算法相同，仔细观察你会发现两者互为逆过程。而$Allgather$操作可以使用递归加倍算法或者环算法，总时间等于两者之和。<br>因此广播操作的二项树算法和$Scatter+Allgather$算法的时间消耗对比如下：<br>$$\left{<br>\begin{matrix}<br> T_{tree}&#x3D;\lceil{\lg{p}}\rceil\cdot(\alpha+n\beta) \<br> {T_{Scatter+Allgather}&#x3D;(\lg{p}+p-1)\alpha+2\frac{p-1}{p}n\beta}<br>\end{matrix}<br>\right.<br>$$<br>对比两个式子我们可以很容易得到：</p><ul><li>当消息两较小（即$n$较小）或者进程数量少时（小于8），我们使用二项树算法；</li><li>当消息较大时或者进程数量较大时，我们采用$Scatter$+$Allgather$的组合算法。</li></ul><h2 id="3、-Reduce-Scatter-操作及其算法"><a href="#3、-Reduce-Scatter-操作及其算法" class="headerlink" title="3、$Reduce-Scatter$操作及其算法"></a>3、$Reduce-Scatter$操作及其算法</h2><p>$Reduce-Scatter$操作（多对多规约）是数据规约操作$Reduce$的一个变种，$Reduce$操作的结果保存在根进程中，而$Reduce-Scatter$将结果散发（$Scatter$）给所有进程。</p><h3 id="二项树Reduce-线性Scatter"><a href="#二项树Reduce-线性Scatter" class="headerlink" title="二项树Reduce+线性Scatter"></a>二项树Reduce+线性Scatter</h3><p>在$MPICH$中的老算法中，$Reduce-Scatter$操作先是将所有进程的数据通过二项树规约到$0$号进程，然后通过线性的散发操作将数据分发出去。二项树规约操作的时间为:<br>$$\lg{p}\cdot(\alpha+n\beta+n\gamma)$$<br>线性散发操作的时间为：<br>$$(p-1)\alpha+(p-1)\cdot\frac{n}{p}\beta$$<br>总的时间为:<br>$$T_{old}&#x3D;(\lg{p}+p-1)\alpha+(\lg{p}+\frac{p-1}{p})n\beta+\lg{p}\cdot{n}\gamma$$</p><h3 id="Recursive-Halving"><a href="#Recursive-Halving" class="headerlink" title="Recursive Halving"></a>Recursive Halving</h3><p>递归减半算法和前面$Allgather$操作的递归加倍算法互为逆过程。</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB45d2ca1b81056825d285e44a1ec85910?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13"/></div> <p>在第1步，进程分为2个子集，每一个进程都和与自己间隔$\frac{p}{2}$的进程交换数据：每一个进程发送另一半集合所有进程都所需要的数据，并且接收自己所在进程集合都需要的数据，然后对收集到的数据进行规约操作。在第2步，每一个进程都和与自己间隔$\frac{p}{4}$的进程交换数据。该过程如此递归进行下去，每一步通信数据也递归减半，进行$\lg{p}$步。算法的时间消耗为：<br>$$T_{rec_halv}&#x3D;\lg{p}\cdot\alpha+\frac{p-1}{p}(n\beta+n\gamma)$$<br>该算法能够正确执行的前提是规约操作是满足交换率的（$commutative$），满足交换律的规约操作使用频率更高，这是由于$\verb+MPI+$定义的许多规约操作都是可交换的，例如$\verb+MPI_SUM+$，$\verb+MPI_MAX+$。如果进程的数量不是2的幂次，我们首先将进程的数量减少到2的幂次，具体做法是最开始的$x$个偶数编号进程发送数据给最近的奇数编号进程（$rank+1$），使得$p-x$为$2$的幂。奇数编号进程对收集的数据执行规约操作，然后这些奇数号进程和其余的$p-2x$个进程（一共$p-x$个）参与递归减半算法中计算自己的结果，最后，前$x$个奇数进程将结果返回给左邻居结点。这样算法的时间为：<br>$$T_{rec_halv}&#x3D;(\lfloor{\lg{p}\rfloor+2)}\alpha+2n\beta+n(1+\frac{p-1}{p})\gamma$$</p><h3 id="Pairwise-Exchange"><a href="#Pairwise-Exchange" class="headerlink" title="Pairwise Exchange"></a>Pairwise Exchange</h3><p>成对交换算法适用于规约操作不满足交换律，其思想类似于$Allgather$操作递归加倍算法。在第$1$步，每一对邻居进程交换数据；第$2$步，彼此间距为$2$的进程交换数据；在第$3$步，彼此间距为$4$的进程交换数据，如此进行下去。然而它相较于$Allgather$操作，交换的数据更多。在第一步，进程交换除了自己所需要数据以外的所有数据（$n-\frac{n}{p}$数据量），比方说0号进程把除了块0之外的$1{\sim}(p-1)$块发送给$1$号进程，1号进程发送除块1之外的$0$、$2{\sim}(p-1)$块发送给$0$号进程；第二步，进程交换除了自己和上一步通信进程所拥有数据以外的所有数据（$n-\frac{2n}{p}$）；第三步数据量为（$n-\frac{4n}{p}$）。这样算法执行的时间为：<br>$$T_{short}&#x3D;\lg{p}\cdot\alpha+(\lg{p}-\frac{p-1}{p})(n\beta+n\alpha)$$<br>该算法适用于传输的消息量小于256B的情况。对长消息发送（满足交换律的操作是$\geqslant256KB$，不满足交换律的操作是$\geqslant256B$），我们使用执行$p-1$步的成对交换算法。在第$i$步，每一个进程向$(rank+i)%p$发送数据，接收来自进程$(rank-i)%p$的数据，并执行局部规约操作。交换的数据仅仅是用于散发结果的的数据量$\frac{n}{p}$，也就是只需要发送每个进程需要的那一部分数据即可。算法执行需要的时间为：<br>$$T_{long}&#x3D;(p-1)\alpha+\frac{p-1}{p}(n\beta+n\gamma)$$<br>Tips:</p><ul><li>Commutative Operations(满足交换律的操作)：MPI定义的数据归约操作包含$\verb+sum+$、$\verb+min+$、$\verb+max+$、$\verb+MinLoc+$、$\verb+MaxLoc+$、$\verb+(bitwise)OR+$、$\verb+AND+$、$\verb+XOR+$等等，其中有些是满足交换律的，有些不满足，</li><li>Associative Operation(满足结合律的操作)：浮点加法和乘法满足交换律但不满足结合律，因为$(a+b)+c\neq$$a+(b+c)$，例如$10^{20}-(10^{20}+\epsilon)&#x3D;0$而$10^{20}-10^{20}-\epsilon&#x3D;-\epsilon$。</li><li>$Recursive$ $Havling$适合于满足交换律的操作，$Recursive$ $Doubling$只适用于满足结合律的操作。</li></ul><p>$\verb+MPI_Reduce_scatter+$策略：</p><ul><li>当操作满足交换律，消息$&lt;{256KB}$采用递归减半算法，$\geqslant{256KB}$则采用$(p-1)$步的成对交换算法；</li><li>操作不满足交换律，消息$&lt;256B$时采用$\lg{p}$步的成对交换算法，$\geqslant{256B}$时采用$(p-1)$步的成对交换算法。</li></ul><h2 id="4、-Reduce-操作及其算法"><a href="#4、-Reduce-操作及其算法" class="headerlink" title="4、$Reduce$操作及其算法"></a>4、$Reduce$操作及其算法</h2><h3 id="Bionomial-Tree-1"><a href="#Bionomial-Tree-1" class="headerlink" title="Bionomial Tree"></a>Bionomial Tree</h3><p>$MPICH$中老算法采用二项树算法，执行$\lg{p}$步，每步都交换一个进程的所有$n$字节数据并进行规约计算，算法的时间为：<br>$$T_{tree}&#x3D;\lceil{\lg{p}}\rceil(\alpha+n\beta+n\gamma)$$</p><h3 id="Reduce-scatter-Gather组合算法"><a href="#Reduce-scatter-Gather组合算法" class="headerlink" title="Reduce_scatter+Gather组合算法"></a>Reduce_scatter+Gather组合算法</h3><p>该算法将$Reduce-scatter$和$Gather$两个操作组合成$Reduce$操作，也叫$Rabenseifner$算法。回顾广播操作的$Scatter+Allgather$组合算法，成功将二项树算法的$\lg{p}\cdot{n\beta}$的带宽项减小到了$2{n\beta}$的数量级，$Reduce$操作类似于广播的逆过程，因此也可以采用类似的思想，$Reduce-scatter$和$Gather$组合的$Reduce$算法也可以将二项树算法的$\lg{p}\cdot{n\beta}$的带宽项减小到了$2{n\beta}$的数量级。算法的时间为$Reduce-scatter$（递归减半算法）和$Gather$（二项树算法）操作的总和，计算为:<br>$$T_{raben}&#x3D;2\lg{p}\cdot\alpha+\frac{p-1}{p}(2n\beta+n\gamma)$$<br>策略：</p><ul><li>当消息量小（$&lt;2KB$）时，采用二项树算法；</li><li>当消息量大（$\geqslant2KB$）时，采用$Reduce-scatter$+$Gather$算法。</li></ul><p>小结：看到这里也应该能摸索出一些规律，大消息发送时（$n$较大）我们要尽量较少带宽项，也就是减少$n\beta$前面的系数，延迟项（也叫启动时间）$\alpha$大一点无所谓；而小消息（$n$较小）发送时我们要尽量较少延迟项。这也就是$Reduce$和$Broadcast$操作选择不同算法时的核心思想。</p><h3 id="Ring-Algorithm-1"><a href="#Ring-Algorithm-1" class="headerlink" title="Ring Algorithm"></a>Ring Algorithm</h3><p>和下面将要介绍的$Ring Allreduce$类似，使用$Reduce-scatter$+$Gather$的方式，但是$Reduce-scatter$只发送一部分数据（$\frac{n}{p}$）给目标进程，且$Gather$阶段使用环算法。</p><h2 id="5、-Allreduce-操作及其算法"><a href="#5、-Allreduce-操作及其算法" class="headerlink" title="5、$Allreduce$操作及其算法"></a>5、$Allreduce$操作及其算法</h2><h3 id="Reduce-Broadcast"><a href="#Reduce-Broadcast" class="headerlink" title="Reduce+Broadcast"></a>Reduce+Broadcast</h3><p>$MPICH$中老算法先将结果$Reduce$到根进程然后再将根进程的结果$Broadcast$到所有进程中。</p><h3 id="Recursive-Doubling-1"><a href="#Recursive-Doubling-1" class="headerlink" title="Recursive Doubling"></a>Recursive Doubling</h3><p>$Allreduce$的递归加倍算法和$Allgather$的递归加倍算法是非常相似的，只是每一步都伴随规约操作且交换的数据量也不同，每次进程间两两交换的数据量都是$n$。因此算法执行的时间为：<br>$$T_{rec_dbl}&#x3D;\lg{p}(\alpha+n\beta+n\gamma)$$</p><h3 id="Reduce-scatter-Allgather"><a href="#Reduce-scatter-Allgather" class="headerlink" title="Reduce_scatter+Allgather"></a>Reduce_scatter+Allgather</h3><p>该算法也叫$Rabenseifner$算法。回顾$Reduce$操作我们采用了$Reduce-scatter$+$Gather$算法，这里我们在第二步将$Gather$换成了$Allgather$操作，采用$Reduce-scatter$+$Allgather$算法。算法的总开销为：<br>$$T_{raben}&#x3D;2\lg{p}\cdot\alpha+\frac{p-1}{p}(2n\beta+n\gamma)$$<br>截至目前，上述$Reduce$操作的$Reduce-scatter$+$Gather$算法和$Allgather$操作的$Reduce-scatter$+$Allgather$算法，当进程的数量不是2的幂次的时候需要额外处理。移除$r&#x3D;p-p^{‘}$个额外进程来将进程数量减少到最接近的2次幂$(p^{‘}&#x3D;2^{\lfloor{\lg{p}}\rfloor})$。前$2r$个进程（$0$号到$2r-1$号）中，所有的偶数进程将输入向量的后半部分发送给右邻居（$rank+1$），所有的奇数进程将输入向量的前半部分发送给左邻居（$rank-1$）。随后偶数进程对前半部分向量进行规约操作，奇数进程对后半部分向量进行规约操作。奇数进程将规约结果发送给左邻居进程。该步骤结束后，前$2r$个进程的偶数编号进程都拥有了和右邻居进程进行规约的结果，而奇数编号进程不会参与算法的后续过程，这样我们就可以把进程的数量减少到2的幂次：最开始的r个偶数进程和最后面的$p-2r$个进程从$0{\sim}(p^{‘}-1)$编号，是2的幂次。然后这些进程再执行$Reduce-scatter$+$Allgather$算法。最后规约的结果还要发送给第一步就已经移除的$r$个进程，如果是$Reduce$操作，根进程在第一步中就被剔除掉了，那么在$Reduce-scatter$操作之后的第一步，该根进程和邻居进程就要互换位置，这样不会增加额外消耗。<br>下图展示了带有13个进程的$Allreduce$操作算法的例子。输入向量和规约结果被分成了8个部分($A,B,…,H$)，因为$8$是小于且最接近$13$的$2$的幂次，用$A{-}H_{rank}$来表示。前2r个（$r&#x3D;13-8&#x3D;5,2r&#x3D;10$）偶数进程先执行两两$Allreduce$操作，然后前$r$个偶数进程（$0$、$2$、$4$、$6$、$8$号）和剩余的$3$（$p-2r&#x3D;3$）个进程（$10$、$11$、$12$号）执行$Reduce-scatter+Allgather$，最后，前$r$个偶数进程（$0$、$2$、$4$、$6$、$8$号）将结果发送给前$r$个奇数进程（$1$、$3$、$5$、$7$、$9$号）.<br><img src="https://note.youdao.com/yws/api/personal/file/WEBca42cd1c5c39305518f9b87e91cbcdb4?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13"></p><h3 id="Bionary-Block-Algorithm"><a href="#Bionary-Block-Algorithm" class="headerlink" title="Bionary Block Algorithm"></a>Bionary Block Algorithm</h3><p>叫做二方块算法。该算法能够降低进程数量非2幂时$Reduce-scatter+Allgather$算法的负载不均衡问题。以下图为例，在初始阶段对进程划分为若干块，使每一个块内进程子集的数量为2的方幂。每个块内部执行$Reduce-scatter$操作。然后，从最小的块开始，被划分为若干段做为更高一块的输入，更高的一块对收集过来的数据执行规约操作，如$\boxed{2^0}$块作为$\boxed{2^2}$块的输入，两个块进行规约，注意$\boxed{2^0}$块的4个数据拷贝与$\boxed{2^2}$块规约，然后$\boxed{2^2}$块做为$\boxed{2^3}$块的输入再进行两个块的规约。小的进程块会造成负载不均衡。两个连续块的最大差异，会决定负载不均衡的程度。定义$\delta_{expo,max}$做为两个连续块数量（均为2的幂次）的最大差值，如$100&#x3D;2^6+2^5+2^2$，则$\delta_{expo,max}&#x3D;max(6-5,5-2)&#x3D;3$，如果$\delta_{expo,max}$值很小，那么算法的性能会很好。<br>在算法的第二阶段，是$Allgather$操作。上一个更大的块必须向小块发送数据，如图。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB493ba0c9657ed9064532a87b08ff8ece?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13"></p><h3 id="Ring-Algorithm-2"><a href="#Ring-Algorithm-2" class="headerlink" title="Ring Algorithm"></a>Ring Algorithm</h3><p>环算法，其实就是$Reduce-scatter+Allgather$算法的变形，在$Reduce-scatter$阶段是各个进程直接将一部分数据发送到其目的节点，并且$Allgather$操作使用环算法来执行。<br>借用$\verb+OpenMPI+$中的例子来解释$Ring\ Allreduce$算法。<br>假设有5个进程，则进程的输入数据分成5份，先进行$Computation\ stage$（也就是$Reduce-scatter$）然后是$Distribution\ phase$（也就是$Allgather$的环算法）。</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEBf2832a760d9e4937101fa93ae4410649?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div> <div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB43f5e95a1868d89cbd317169ea87df53?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div> <div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEB169bdb1ca360203ba6ff2fdee5ddae24?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div> <p>该算法的执行时间为：<br>$$T_{ring}&#x3D;2(p-1)\alpha+\frac{p-1}{p}(2n\beta+n\gamma)$$</p><h2 id="Allreduce选择最佳算法"><a href="#Allreduce选择最佳算法" class="headerlink" title="Allreduce选择最佳算法"></a>Allreduce选择最佳算法</h2><p>在上面介绍的$Allreduce$的$5$种算法中根据进程数量和消息大小来选择不同算法，这张图是展示不同进程数量和消息大小对应的最佳算法（对$\verb+MPI_DOUBLE+$型的数据进行$\verb+MPI_SUM+$求和操作）。$havling+doubling$就是$Reduce-scatter+Allgather$算法。</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEBcc34716f4289d3c74ac7e0bd65786af4?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div> <p>这个是消息大小为$32KB$时对$\verb+MPI_DOUBLE+$型的数据进行$\verb+MPI_SUM+$求和操作不同算法的带宽。</p><div style="align: center"><img src="https://note.youdao.com/yws/api/personal/file/WEBa4ff21d874a476bc6a4110496d8d7bbc?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div> <p>策略：</p><ul><li>对于短消息，使用$Recursive Doubling$算法;</li><li>对于长消息，先进行$Reduce-scatter$（$Recursive-halving$算法），再进行$Allgather$（$Recursive\ Doubling$算法）。</li></ul><p>后面的三种方法只是进一步优化，没有在$\verb+MPICH+$里集成。</p><h1 id="Allreduce算法的评估和对比"><a href="#Allreduce算法的评估和对比" class="headerlink" title="Allreduce算法的评估和对比"></a>Allreduce算法的评估和对比</h1><p>常用的经典$Allreduce$算法的消耗评估模型：</p><table><thead><tr><th align="left">Allreduce Algorithm</th><th align="left">Cost Model</th><th align="left">Efficient Bandwidth</th></tr></thead><tbody><tr><td align="left">Reduce + Broadcast</td><td align="left">$2\lceil{\lg{p}}\rceil(\alpha+n\beta)+n\gamma$</td><td align="left">$\frac{B}{2}$</td></tr><tr><td align="left">Recursive Doubling</td><td align="left">$\lg{p}(\alpha+n\beta+n\gamma)$</td><td align="left">…</td></tr><tr><td align="left">Reduce-Scatter + Allgather</td><td align="left">$2\lg{p}\cdot\alpha+\frac{p-1}{p}(2n\beta+n\gamma)$</td><td align="left">…</td></tr><tr><td align="left">Binary Block</td><td align="left">…</td><td align="left">…</td></tr><tr><td align="left">Ring Algorithm</td><td align="left">$2(p-1)\alpha+\frac{p-1}{p}(2n\beta+n\gamma)$</td><td align="left">$\frac{nB}{2(n-1)B}$</td></tr></tbody></table><h1 id="OpenMPI和MPICH中的Allreduce算法"><a href="#OpenMPI和MPICH中的Allreduce算法" class="headerlink" title="OpenMPI和MPICH中的Allreduce算法"></a>OpenMPI和MPICH中的Allreduce算法</h1><h2 id="1、OpenMPI-4-1-2的MPI-Allreduce实现"><a href="#1、OpenMPI-4-1-2的MPI-Allreduce实现" class="headerlink" title="1、OpenMPI-4.1.2的MPI_Allreduce实现"></a>1、OpenMPI-4.1.2的MPI_Allreduce实现</h2><p>$\verb+OpenMPI-4.1.2+$是最新版本的$\verb+OpenMPI+$，算法的具体选择在$\verb+ompi&#x2F;mca&#x2F;coll&#x2F;tuned&#x2F;coll_tuned_decision_fixed.c+$和$\verb+ompi&#x2F;mca&#x2F;coll&#x2F;tuned&#x2F;coll_tuned_decision_dynamic.c+$文件里，用户可以指定规则以及选择使用的算法，并且$\verb+OpenMPI+$使用了6种算法，分别是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Algorithms:</span><br><span class="line">   &#123;<span class="number">1</span>, <span class="string">&quot;basic_linear&quot;</span>&#125;: Reduce + Broadcast</span><br><span class="line">   &#123;<span class="number">2</span>, <span class="string">&quot;nonoverlapping&quot;</span>&#125;: Reduce +Broadcast</span><br><span class="line">   &#123;<span class="number">3</span>, <span class="string">&quot;recursive_doubling&quot;</span>&#125;: Recursive Doubling</span><br><span class="line">   &#123;<span class="number">4</span>, <span class="string">&quot;ring&quot;</span>&#125;: Ring(Segmented Messages) + Allgather(Ring)</span><br><span class="line">   &#123;<span class="number">5</span>, <span class="string">&quot;segmented_ring&quot;</span>&#125;: Segmented Ring</span><br><span class="line">   &#123;<span class="number">6</span>, <span class="string">&quot;rabenseifner&quot;</span>&#125;: Reduce-Scatter + Allgather</span><br><span class="line">   <span class="comment">/* Currently, ring, segmented ring, and rabenseifner do not support non-commutative operations. */</span></span><br></pre></td></tr></table></figure><p>默认使用$\verb+&#x2F;coll_tuned_decision_fixed.c+$里的规则（固定算法选择规则），具体的选择方法如下(原代码是100多行的$else-if$，贼暴力)：<br><img src="https://note.youdao.com/yws/api/personal/file/WEBef75c5797a8fe9a7d3afe7d9f84db3a2?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13"><br><img src="https://note.youdao.com/yws/api/personal/file/WEBe38b3f100dd6599ec413faa1ee25edcf?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13"><br>除了默认的规则之外，用户还可以指定参数来选择对应的算法。<br>函数选择逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态算法选择规则</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ompi_coll_tuned_allreduce_intra_dec_dynamic</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果指定了filebased rules(暂不知道这是啥);</span></span><br><span class="line">    <span class="keyword">if</span> (tuned_module-&gt;com_rules[ALLREDUCE])</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> algorithm = ompi_coll_tuned_get_target_method_params();</span><br><span class="line">        <span class="keyword">if</span>(algorithm) <span class="keyword">return</span> ompi_coll_tuned_allreduce_intra_do_this(..., algorithm, ...)</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">switch</span> (algorithm) &#123;</span><br><span class="line">                <span class="keyword">case</span> (<span class="number">0</span>): <span class="keyword">return</span> ompi_coll_tuned_allreduce_intra_dec_fixed();</span><br><span class="line">                <span class="keyword">case</span> (<span class="number">1</span>): <span class="keyword">return</span> ompi_coll_base_allreduce_intra_basic_linear();</span><br><span class="line">                <span class="keyword">case</span> (<span class="number">2</span>): <span class="keyword">return</span> ompi_coll_base_allreduce_intra_nonoverlapping();</span><br><span class="line">                <span class="keyword">case</span> (<span class="number">3</span>): <span class="keyword">return</span> ompi_coll_base_allreduce_intra_recursivedoubling();</span><br><span class="line">                <span class="keyword">case</span> (<span class="number">4</span>): <span class="keyword">return</span> ompi_coll_base_allreduce_intra_ring();</span><br><span class="line">                <span class="keyword">case</span> (<span class="number">5</span>): <span class="keyword">return</span> ompi_coll_base_allreduce_intra_ring_segmented();</span><br><span class="line">                <span class="keyword">case</span> (<span class="number">6</span>): <span class="keyword">return</span> ompi_coll_base_allreduce_intra_redscat_allgather();</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果用户指定了算法;</span></span><br><span class="line">    <span class="keyword">if</span> (tuned_module-&gt;user_forced[ALLREDUCE].algorithm)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ompi_coll_tuned_allreduce_intra_do_this(..., algorithm, ...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若用户没指定算法，则使用固定规则</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ompi_coll_tuned_allreduce_intra_dec_fixed(...)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> ompi_coll_tuned_allreduce_intra_dec_fixed (...)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//100多行的if-else, 根据进程数量和消息量确定algorithm(从1~6选一个值)</span></span><br><span class="line">            <span class="keyword">return</span> ompi_coll_tuned_allreduce_intra_do_this (..., algorithm, ...);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、MPICH-4-0-2的MPI-Allreduce实现"><a href="#2、MPICH-4-0-2的MPI-Allreduce实现" class="headerlink" title="2、MPICH-4.0.2的MPI_Allreduce实现"></a>2、MPICH-4.0.2的MPI_Allreduce实现</h2><p>$MPI$应用程序在调用$\verb+MPI_Allreduce+$时执行的主要算法、主要函数以及选择逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Algorithm:</span></span><br><span class="line"><span class="comment">        Intra Communication:</span></span><br><span class="line"><span class="comment">            Recursive Doubling;</span></span><br><span class="line"><span class="comment">            Reduce-scatter + Allgather</span></span><br><span class="line"><span class="comment">            Nb(Nonblocking Allreduce + Wait)</span></span><br><span class="line"><span class="comment">            Smp(Local Reduce + Bcast)</span></span><br><span class="line"><span class="comment">        Inter Communication:</span></span><br><span class="line"><span class="comment">            Reduce-exchange + Bcast</span></span><br><span class="line"><span class="comment">            Nb(Nonblocking Allreduce + Wait)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">MPI_Allreduce</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *sendbuf, <span class="type">void</span> *recvbuf, <span class="type">int</span> count, MPI_Datatype datatype, MPI_Op op, MPI_Comm comm)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    MPIR_Allreduce(sendbuf, recvbuf, count, datatype, op, comm_ptr, &amp;errflag)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        MPIR_Allreduce_impl(sendbuf, recvbuf, count, datatype, op, comm_ptr, &amp;errflag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="comment">/*intra communicator*/</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span>(intra_alrogithm)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> intra_recursive_doubling:</span><br><span class="line">                        MPIR_Allreduce_intra_recursive_doubling(...);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> intra_reduce_scatter_allgather:</span><br><span class="line">                        MPIR_Allreduce_intra_reduce_scatter_allgather(...);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> nb:</span><br><span class="line">                        MPIR_Allreduce_allcomm_nb(...);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> intra_smp:</span><br><span class="line">                        MPIR_Allreduce_intra_smp(...);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="keyword">auto</span>:</span><br><span class="line">                        MPIR_Allreduce_allcomm_auto(...)</span><br><span class="line">                        &#123;</span><br><span class="line">                            MPII_Csel_container_s *cnt = MPIR_Csel_search(comm_ptr-&gt;csel_comm, coll_sig);</span><br><span class="line">                            <span class="keyword">switch</span> (cnt-&gt;id)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">case</span> intra_recursive_doubling:</span><br><span class="line">                                    MPIR_Allreduce_intra_recursive_doubling(...);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> intra_reduce_scatter_allgather:</span><br><span class="line">                                    MPIR_Allreduce_intra_reduce_scatter_allgather(...);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> intra_smp:</span><br><span class="line">                                    MPIR_Allreduce_intra_smp(...);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> inter_reduce_exchange_bcast:</span><br><span class="line">                                    MPIR_Allreduce_inter_reduce_exchange_bcast(...);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> nb:</span><br><span class="line">                                    MPIR_Allreduce_allcomm_nb(...)</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        MPIR_Iallreduce(...);       <span class="comment">/*Nonblocking Allreduce*/</span></span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">/*inter communicator*/</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span>(inter_algorithm)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> inter_reduce_exchange_bcast:</span><br><span class="line">                        MPIR_Allreduce_inter_reduce_exchange_bcast(...);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> nb:</span><br><span class="line">                        MPIR_Allreduce_allcomm_nb(...);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="keyword">auto</span>:</span><br><span class="line">                        MPIR_Allreduce_allcomm_auto(...);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
          <category> 并行计算 </category>
          
          <category> MPI集合通信算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MPI </tag>
            
            <tag> 并行计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cannon矩阵乘法</title>
      <link href="/2022/03/26/Cannon/"/>
      <url>/2022/03/26/Cannon/</url>
      
        <content type="html"><![CDATA[<p>$Cannon$算法是并行矩阵乘法的经典算法，将多个处理器排列成二维网格，采用二维块划分的方法将矩阵分给不同的处理器计算各自的局部结果，以此来加速计算。在本文中，为方便起见，示例程序中的矩阵均为$n$阶方阵，处理器的数量为2的幂次，确保每个矩阵得到的局部矩阵的元素个数相同。</p><h1 id="一、二维矩阵串行乘法"><a href="#一、二维矩阵串行乘法" class="headerlink" title="一、二维矩阵串行乘法"></a>一、二维矩阵串行乘法</h1><p>两个$n$维方阵的乘法$A \cdot B &#x3D; C$的串行计算公式为：<br>$$ C_{ij} &#x3D; \sum_{k&#x3D;0}^{n-1} A_{ik} \cdot B_{kj},. $$<br>程序可以表示为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Multiply</span><span class="params">(<span class="type">double</span>* A, <span class="type">double</span>* B, <span class="type">double</span>* C, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">C[i * n + j] += A[i * n + k] * B[j + k * n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序将二维矩阵用一维矩阵线性展开，用一维数组来模拟二维数组。</p><h1 id="二、Cannon算法"><a href="#二、Cannon算法" class="headerlink" title="二、Cannon算法"></a>二、Cannon算法</h1><p>并行化二维矩阵乘法的一种思想是二维块划分方法，将$p,$ 个进程（$p,$为完全平方数）排列成$\sqrt[]{p}\times\sqrt[]{p},$二维网格，然后将矩阵$A、B、C,$都分成$\sqrt[]{p}\times\sqrt[]{p},$ 块，均匀分布在网格上，矩阵第$(i,j),$个子块分别记为$A_{ij},$、$B_{ij},$、$C_{ij},$，存储在二维进程网格上坐标为$(i,j),$的进程$P_{ij},$上。计算$C_{ij},$时要将$A_{ik},$(第$i,$行进程上的所有$A,$的子块)和$B_{kj},$(第$j,$列进程上的所有$B,$的子块)都收集到进程$P_{ij},$上，再计算$C_{ij},$，公式可以表达为：<br>$$C_{ij} &#x3D; \sum_{k&#x3D;0}^{\sqrt[]{p}-1} A_{ik} \cdot B_{kj}$$<br>如下图所示：<br><img src="https://img-blog.csdnimg.cn/d00915586a8d405c973cfd0903f821b7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qWa5Zu95Luk5bC5,size_30,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="二维块划分"></p><p>然而每一个进程都重复收集$A_{ik},$和$B_{kj},$会造成空间的大量浪费，时间效率也比较低，于是有了更高效的$Canon,$算法，其表达式为：<br>$$C_{ij} &#x3D; \sum_{k&#x3D;0}^{\sqrt[]{p}-1} A_{i,(i+j+k)%\sqrt[]{p}} \cdot B_{(i+j+k)%\sqrt[]{p},j}$$</p><p>$Canon,$算法基本思想是，每一个进程只存储$A,$、$B,$、$C,$矩阵的一个子块，本地相对应的$A,$、$B,$子块相乘后将结果累加到本地$C,$子块上，然后再与其他进程交换$A,$、$B,$子块，继续相乘将结果累加到本地$C,$子块上。但是要保证对应的$A,$、$B,$子块相乘，不能错位，我们注意到，在最开始，$P_{ij},$上的$A,$为所在行的第$j,$个，$B,$为所在列的第$i,$个，$A,$和$B,$子块并不对应，因此将一行上的$A,$子块循环向左移动$i,$格，一列上的$B,$子块循环向上移动$j,$格，这样$A,$和$B,$子块就能对应了，以后每执行一次计算，每行所有$A,$子块循环向左移动1格，每列上的$B,$子块循环向上移动1格，$A,$、$B,$子块相乘的结果累加在本地的$C,$子块上。<br><img src="https://img-blog.csdnimg.cn/4e1f8ac94d8e4de89df2fbd4707042fa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qWa5Zu95Luk5bC5,size_30,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="排列"></p><p>算法的个步骤表示如下：</p><h2 id="1、第一次重排列"><a href="#1、第一次重排列" class="headerlink" title="1、第一次重排列"></a>1、第一次重排列</h2><p>$k&#x3D;0$时，$A_{i,(i+j)%\sqrt[]{p}}$并不处于$P_{ij},$上，需要对齐，于是$A_{i,(i+j)%\sqrt[]{p}}$传送到$P_{ij},$上，具体的实现方式是，二维网格上每一行的进程都将$A,$子块循环向左移位，第$i,$行的所有进程将$A,$子块循环向左移位$i,$个单位；同时$B_{(i+j)%\sqrt[]{p},j}$并不处于$P_{ij},$上，$B_{(i+j)%\sqrt[]{p},j}$传送到$P_{ij},$上，第$j,$列的所有进程将$B,$子块循环向上移位$j,$个单位，如下图所示：<br><img src="https://img-blog.csdnimg.cn/8b687e17cec04361b3581c9ba7c50838.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qWa5Zu95Luk5bC5,size_30,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="初始排列"><br>得到的第一次重排列后的矩阵排列为：<br><img src="https://img-blog.csdnimg.cn/af16cd39d9ef459b96bdef69b410355b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qWa5Zu95Luk5bC5,size_30,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="第一次重排列后"><br>每个进程得到初次重排列后的$A,$、$B,$子块后，将$A,$、$B,$子块相乘的结果累加在本地的$C,$子块上。</p><h2 id="2、后续重排列"><a href="#2、后续重排列" class="headerlink" title="2、后续重排列"></a>2、后续重排列</h2><p>以后每进行一次计算，每行进程的$A,$子块都循环向左移动一个单位，每列进程的$B,$子块都循环的向上移动一个单位，如下图所示，$A,$、$B,$子块相乘的结果累加在本地的$C,$子块上，该步骤重复$\sqrt[]{p}-1,$次。<br><img src="https://img-blog.csdnimg.cn/643bf8d4f65c444288bc7e7eae8314fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qWa5Zu95Luk5bC5,size_35,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="重排列"><br>最后进程$P_{ij},$上能够得到本地的结果$C_{ij},$。</p><h1 id="三、程序实现"><a href="#三、程序实现" class="headerlink" title="三、程序实现"></a>三、程序实现</h1><h2 id="1、创建二维进程拓扑结构"><a href="#1、创建二维进程拓扑结构" class="headerlink" title="1、创建二维进程拓扑结构"></a>1、创建二维进程拓扑结构</h2><p>创建进程二维拓扑结构的函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dims[<span class="number">0</span>] = dims[<span class="number">1</span>] = <span class="built_in">sqrt</span>(comm_size);</span><br><span class="line">periods[<span class="number">0</span>] = periods[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">MPI_Cart_create(MPI_COMM_WORLD, <span class="number">2</span>, dims, periods, <span class="number">1</span>, &amp;comm_2d);</span><br></pre></td></tr></table></figure><p>$comm_size,$为进程的总数量，$dims[2],$数组表示二维拓扑结构中每一维的大小，$period[2],$全部设置成1，表示拓扑结构的第$i,$维有环绕接。这样我们得到了新的进程通讯器$comm_2d,$。由于每一个进程都会被分配一个进程号以及进程坐标，从进程号获取进程坐标的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MPI_Cart_coords(comm_2d, myrank, <span class="number">2</span>, mycoords);</span><br></pre></td></tr></table></figure><p>$myrank,$是进程序号，$mycoords,$是大小为2的一维数组。</p><h2 id="2、输入输出矩阵"><a href="#2、输入输出矩阵" class="headerlink" title="2、输入输出矩阵"></a>2、输入输出矩阵</h2><p>输入输出矩阵均为$8\times8,$矩阵，$A,$、$B,$矩阵均为正交矩阵，且$B&#x3D;A^{T},$，$A,$矩阵为：<br><img src="https://img-blog.csdnimg.cn/26b328173bcf48a1bb1d0c38f6439597.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qWa5Zu95Luk5bC5,size_30,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="A矩阵"><br>计算结果应该可以得到一个单位矩阵。</p><h2 id="3、主程序"><a href="#3、主程序" class="headerlink" title="3、主程序"></a>3、主程序</h2><p>每个进程保存的本地矩阵子块分别为$local_A,$、$local_B,$、$local_C,$，方便起见，进程的数量设为1、4、16、64这4种情况中的一种。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi acos(-1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> myrank, comm_size, srcrank, dstrank;</span><br><span class="line"><span class="type">int</span> dims[<span class="number">2</span>], periods[<span class="number">2</span>], mycoords[<span class="number">2</span>], coords[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n = <span class="number">8</span>, local_n;</span><br><span class="line">MPI_Comm comm_2d;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Multiply</span><span class="params">(<span class="type">double</span>* A, <span class="type">double</span>* B, <span class="type">double</span>* C, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GenerateData</span><span class="params">(MPI_Comm comm_2d, <span class="type">double</span>* local_A, <span class="type">double</span>* local_B)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Cannon</span><span class="params">(MPI_Comm comm_2d, <span class="type">double</span>* local_A, <span class="type">double</span>* local_B, <span class="type">double</span>* local_C)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GatherResult</span><span class="params">(MPI_Comm comm_2d, <span class="type">double</span>* local_C)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span>* local_A, * local_B, * local_C;</span><br><span class="line"></span><br><span class="line">MPI_Init(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">MPI_Comm_size(MPI_COMM_WORLD, &amp;comm_size);</span><br><span class="line">MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myrank == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;Number of Process: %d\n&quot;</span>, comm_size);</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> start = MPI_Wtime();</span><br><span class="line"></span><br><span class="line">dims[<span class="number">0</span>] = dims[<span class="number">1</span>] = <span class="built_in">sqrt</span>(comm_size);</span><br><span class="line">periods[<span class="number">0</span>] = periods[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">MPI_Cart_create(MPI_COMM_WORLD, <span class="number">2</span>, dims, periods, <span class="number">1</span>, &amp;comm_2d);</span><br><span class="line"></span><br><span class="line">MPI_Comm_rank(comm_2d, &amp;myrank);</span><br><span class="line">MPI_Cart_coords(comm_2d, myrank, <span class="number">2</span>, mycoords);</span><br><span class="line"></span><br><span class="line">local_n = n / dims[<span class="number">0</span>];</span><br><span class="line">local_A = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line">local_B = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line">local_C = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line"><span class="built_in">memset</span>(local_A, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line"><span class="built_in">memset</span>(local_B, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line"><span class="built_in">memset</span>(local_C, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line"></span><br><span class="line">GenerateData(comm_2d, local_A, local_B);</span><br><span class="line">Cannon(comm_2d, local_A, local_B, local_C);</span><br><span class="line">GatherResult(comm_2d, local_C);</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> end = MPI_Wtime();</span><br><span class="line"><span class="keyword">if</span>(myrank == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;Running time: %.2f seconds...\n&quot;</span>, end - start);</span><br><span class="line"></span><br><span class="line">MPI_Comm_free(&amp;comm_2d);</span><br><span class="line">MPI_Finalize();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、Cannon算法主函数"><a href="#4、Cannon算法主函数" class="headerlink" title="4、Cannon算法主函数"></a>4、Cannon算法主函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Cannon</span><span class="params">(MPI_Comm comm_2d, <span class="type">double</span>* local_A, <span class="type">double</span>* local_B, <span class="type">double</span>* local_C)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> uprank, downrank, leftrank, rightrank;</span><br><span class="line">MPI_Status status;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算左边一格的（目标）进程序号leftrank，和右边一格的（源）进程序号rightrank</span></span><br><span class="line">coords[<span class="number">0</span>] = mycoords[<span class="number">0</span>];</span><br><span class="line">coords[<span class="number">1</span>] = (mycoords[<span class="number">1</span>] - <span class="number">1</span>) % dims[<span class="number">1</span>];</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;leftrank);</span><br><span class="line">coords[<span class="number">1</span>] = (mycoords[<span class="number">1</span>] + <span class="number">1</span>) % dims[<span class="number">1</span>];</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;rightrank);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算向上一格的（目标）进程序号uprank，和向下一格的（源）进程序号downrank</span></span><br><span class="line">coords[<span class="number">0</span>] = (mycoords[<span class="number">0</span>] - <span class="number">1</span>) % dims[<span class="number">0</span>];</span><br><span class="line">coords[<span class="number">1</span>] = mycoords[<span class="number">1</span>];</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;uprank);</span><br><span class="line">coords[<span class="number">0</span>] = (mycoords[<span class="number">0</span>] + <span class="number">1</span>) % dims[<span class="number">0</span>];</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;downrank);</span><br><span class="line"></span><br><span class="line"><span class="comment">//A矩阵第一次重排列</span></span><br><span class="line">coords[<span class="number">0</span>] = mycoords[<span class="number">0</span>];</span><br><span class="line">coords[<span class="number">1</span>] = (mycoords[<span class="number">1</span>] - mycoords[<span class="number">0</span>]) % dims[<span class="number">1</span>];</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;dstrank);</span><br><span class="line">coords[<span class="number">1</span>] = (mycoords[<span class="number">1</span>] + mycoords[<span class="number">0</span>]) % dims[<span class="number">1</span>];</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;srcrank);</span><br><span class="line"><span class="keyword">if</span> (myrank != dstrank)</span><br><span class="line">&#123;</span><br><span class="line">MPI_Sendrecv_replace(local_A, local_n * local_n, MPI_DOUBLE, dstrank, <span class="number">0</span>, srcrank, <span class="number">0</span>, comm_2d, &amp;status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B矩阵第一次重排列</span></span><br><span class="line">coords[<span class="number">1</span>] = mycoords[<span class="number">1</span>];</span><br><span class="line">coords[<span class="number">0</span>] = (mycoords[<span class="number">0</span>] - mycoords[<span class="number">1</span>]) % dims[<span class="number">0</span>];</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;dstrank);</span><br><span class="line">coords[<span class="number">0</span>] = (mycoords[<span class="number">0</span>] + mycoords[<span class="number">1</span>]) % dims[<span class="number">0</span>];</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;srcrank);</span><br><span class="line"><span class="keyword">if</span> (myrank != dstrank)</span><br><span class="line">&#123;</span><br><span class="line">MPI_Sendrecv_replace(local_B, local_n * local_n, MPI_DOUBLE, dstrank, <span class="number">0</span>, srcrank, <span class="number">0</span>, comm_2d, &amp;status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Multiply(local_A, local_B, local_C, local_n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> time = <span class="number">0</span>; time &lt; dims[<span class="number">0</span>] - <span class="number">1</span>; time++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//local_A循环往左滚动一格</span></span><br><span class="line">MPI_Sendrecv_replace(local_A, local_n * local_n, MPI_DOUBLE, leftrank, <span class="number">0</span>, rightrank, <span class="number">0</span>, comm_2d, &amp;status);</span><br><span class="line"></span><br><span class="line"><span class="comment">//local_B循环往上滚动一个</span></span><br><span class="line">MPI_Sendrecv_replace(local_B, local_n * local_n, MPI_DOUBLE, uprank, <span class="number">0</span>, downrank, <span class="number">0</span>, comm_2d, &amp;status);</span><br><span class="line"></span><br><span class="line">Multiply(local_A, local_B, local_C, local_n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Multiply</span><span class="params">(<span class="type">double</span>* A, <span class="type">double</span>* B, <span class="type">double</span>* C, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line">C[i * n + j] += A[i * n + k] * B[j + k * n];</span><br><span class="line">Sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中$MPI_Cart_rank,$用于将进程坐标转换为进程号，$MPI_Sendrecv_replace,$函数可以视为$MPI_Send$以及$MPI_Recv,$函数的组合，用于在一个绕接环中，每一个进程向目标进程$dstrank$发送数据，并接受来自$srcrank$源进程的数据，并且在收发数据中所有进程使用的都是同一个缓存。使用该函数可以实现$A$、$B$子块的循环移位。</p><h2 id="5、生成数据并分发到各进程的函数"><a href="#5、生成数据并分发到各进程的函数" class="headerlink" title="5、生成数据并分发到各进程的函数"></a>5、生成数据并分发到各进程的函数</h2><p>0号进程将$A$、$B$矩阵的数据放入$bufferA$、$bufferB$中再发送给对应进程的$local_A$、$local_B$中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GenerateData</span><span class="params">(MPI_Comm comm_2d, <span class="type">double</span>* local_A, <span class="type">double</span>* local_B)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mycoords[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; mycoords[<span class="number">1</span>] == <span class="number">0</span>)<span class="comment">//0号进程生成和发送数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> A[<span class="number">8</span> * <span class="number">8</span>] = &#123;</span><br><span class="line"><span class="built_in">cos</span>(pi / <span class="number">6</span>), -<span class="built_in">sin</span>(pi / <span class="number">6</span>), <span class="number">0</span>, <span class="number">0</span> , <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="built_in">sin</span>(pi / <span class="number">6</span>), <span class="built_in">cos</span>(pi / <span class="number">6</span>), <span class="number">0</span>, <span class="number">0</span> , <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="built_in">cos</span>(pi / <span class="number">4</span>), -<span class="built_in">sin</span>(pi / <span class="number">4</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sin</span>(pi / <span class="number">4</span>), <span class="built_in">cos</span>(pi / <span class="number">4</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">cos</span>(pi / <span class="number">6</span>), -<span class="built_in">sin</span>(pi / <span class="number">6</span>), <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sin</span>(pi / <span class="number">6</span>), <span class="built_in">cos</span>(pi / <span class="number">6</span>), <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">cos</span>(pi / <span class="number">4</span>),  -<span class="built_in">sin</span>(pi / <span class="number">4</span>),</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sin</span>(pi / <span class="number">4</span>), <span class="built_in">cos</span>(pi / <span class="number">4</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>* B = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * n * n);</span><br><span class="line"><span class="built_in">memset</span>(B, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>) * n * n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">B[j * n + i] = A[i * n + j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; local_n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; local_n; j++)</span><br><span class="line">&#123;</span><br><span class="line">local_A[i * local_n + j] = A[i * n + j];</span><br><span class="line">local_B[i * local_n + j] = B[i * n + j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; dims[<span class="number">0</span>]; row++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; dims[<span class="number">1</span>]; col++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (row == <span class="number">0</span> &amp;&amp; col == <span class="number">0</span>) <span class="keyword">continue</span>;<span class="comment">//0号进程</span></span><br><span class="line"><span class="comment">//offset是坐标为(row,col)进程对应的A、B子块的第一个元素在A、B矩阵中的下标</span></span><br><span class="line"><span class="type">int</span> offset = row * dims[<span class="number">1</span>] * local_n * local_n + col * local_n;</span><br><span class="line"><span class="type">double</span>* bufferA = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line"><span class="type">double</span>* bufferB = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; local_n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; local_n; j++)</span><br><span class="line">&#123;</span><br><span class="line">bufferA[i * local_n + j] = A[offset + i * n + j];</span><br><span class="line">bufferB[i * local_n + j] = B[offset + i * n + j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">coords[<span class="number">0</span>] = row;</span><br><span class="line">coords[<span class="number">1</span>] = col;</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;dstrank);</span><br><span class="line">MPI_Send(bufferA, local_n * local_n, MPI_DOUBLE, dstrank, <span class="number">0</span>, comm_2d);</span><br><span class="line">MPI_Send(bufferB, local_n * local_n, MPI_DOUBLE, dstrank, <span class="number">1</span>, comm_2d);</span><br><span class="line"><span class="built_in">free</span>(bufferA);</span><br><span class="line"><span class="built_in">free</span>(bufferB);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">MPI_Recv(local_A, local_n * local_n, MPI_DOUBLE, <span class="number">0</span>, <span class="number">0</span>, comm_2d, MPI_STATUS_IGNORE);</span><br><span class="line">MPI_Recv(local_B, local_n * local_n, MPI_DOUBLE, <span class="number">0</span>, <span class="number">1</span>, comm_2d, MPI_STATUS_IGNORE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、收集结果到0号进程的函数"><a href="#6、收集结果到0号进程的函数" class="headerlink" title="6、收集结果到0号进程的函数"></a>6、收集结果到0号进程的函数</h2><p>所有进程将计算结果（本地$C$子块的数据）放入$bufferC$中发送给0号进程，0号进程收集$bufferC$中的数据放入$C$矩阵的对应位置中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GatherResult</span><span class="params">(MPI_Comm comm_2d, <span class="type">double</span>* local_C)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> otherrank;</span><br><span class="line">MPI_Status status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (coords[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; coords[<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span>* C = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * n * n);</span><br><span class="line"><span class="built_in">memset</span>(C, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>) * n * n);</span><br><span class="line"><span class="type">double</span>* bufferC = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line"><span class="built_in">memset</span>(bufferC, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; dims[<span class="number">0</span>]; row++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; dims[<span class="number">1</span>]; col++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (row == <span class="number">0</span> &amp;&amp; col == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; local_n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; local_n; j++)</span><br><span class="line">C[i * n + j] = local_C[i * local_n + j];</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">coords[<span class="number">0</span>] = row;</span><br><span class="line">coords[<span class="number">1</span>] = col;</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;otherrank);</span><br><span class="line">MPI_Recv(bufferC, local_n * local_n, MPI_DOUBLE, otherrank, <span class="number">0</span>, comm_2d, &amp;status);</span><br><span class="line"><span class="type">int</span> offset = row * dims[<span class="number">1</span>] * local_n * local_n + col * local_n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; local_n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; local_n; j++)</span><br><span class="line">C[offset + i * n + j] = bufferC[i * local_n + j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(bufferC);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>, C[i * n + j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">MPI_Send(local_C, local_n * local_n, MPI_DOUBLE, <span class="number">0</span>, <span class="number">0</span>, comm_2d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、实现结果"><a href="#四、实现结果" class="headerlink" title="四、实现结果"></a>四、实现结果</h1><p>程序在$VS2019$上运行，可以看到随着进程数量的增加，$0$号进程的运行时间明显减少（显示器上显示的执行时间是$0$号进程的执行时间）。但是当进程增加到原来的$n$倍，$0$号进程的运行时间并不为原来的$\frac{1}{n}$，这一方面是因为$0$号进程需要与更多的进程点对点发送$A$、$B$矩阵的数据，另一个重要原因是我的电脑为$Intel$ $8$核$CPU$，最多只能有$8$个进程同时运行，因此会有$64-8&#x3D;56$个进程会在等待队列和就绪队列上等待被$CPU$调度，影响总程序运行时间。但是多个进程确实明显加速了矩阵乘法。<br><img src="https://img-blog.csdnimg.cn/bf1ed6fdf2b64112bb938e070825e933.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qWa5Zu95Luk5bC5,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
          <category> 并行计算 </category>
          
          <category> 并行程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MPI </tag>
            
            <tag> 并行计算 </tag>
            
            <tag> 并行算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在西交的四年光影</title>
      <link href="/2022/03/26/xjtu/"/>
      <url>/2022/03/26/xjtu/</url>
      
        <content type="html"><![CDATA[<p>本科快结束时我在知乎记录过我自己<a href="https://www.zhihu.com/question/401648285/answer/1913831750">本科四年在XJTU的生活</a>，每每看到这些照片都甚是怀念。  </p><p>1、$2021$年$7$月$3$日 于$XJTU$兴庆校区 毕业典礼<br><img src="https://pic3.zhimg.com/80/v2-08e0533dcf8552445840444da46f330f_1440w.jpg?source=c8b7c179" alt="毕业典礼">  </p><p>2、XJTU Airforce（造固定翼飞机）<br>$2019$年$10$月$2$日 于$XJTU$创新港校区 地面抓拍下的飞机俯冲照片：<br><img src="https://pica.zhimg.com/v2-0cbb8d7df835d25ebc9657d18e3b65b4_r.jpg?source=c8b7c179" alt="低空突防"><br>$2019$年$10$月$3$日 创新港校区 飞行曲线第一次完美与GPS航线吻合(卫星地图因为网络原因没加载出来)，飞机摇身一变可以改装成战术巡航导弹（制导算法是一样的）：<br><img src="https://note.youdao.com/yws/api/personal/file/WEBc04c576c0477e79ec40d056cad21e2e1?method=download&shareKey=db01fa57b10b434ada861e14c93e6ff2" alt="GPS航线和制导轨迹"><br>$2$万元在天上飞(还有摄像头、图传等等设备没放出来)<br><img src="https://pic1.zhimg.com/80/v2-f3c5aa9b010c44d0e7329bcb13c2a729_1440w.jpg?source=c8b7c179" alt="飞机零件"><br>$2019$年$7$月$21$日 西安青龙寺 第一次实现自动飞行<br><img src="https://note.youdao.com/yws/api/personal/file/WEB42f30bf30fd615e361f996891170e7e3?method=download&shareKey=db01fa57b10b434ada861e14c93e6ff2" alt="土豚号（名字越贱越不容易炸机）"><br>$2019$年$5$月$25$日 西安青龙寺 场外调试<br><img src="https://note.youdao.com/yws/api/personal/file/WEB64e5cbaefedb292fd180a1335b8e7b4a?method=download&shareKey=db01fa57b10b434ada861e14c93e6ff2" alt="场外调试">  </p><p>3、$2020$年$6$月$14$日 用计算机视觉的方法计算出了$XJTU$主楼的高度为105米<br><img src="https://pic2.zhimg.com/80/v2-f8f1eaa664c20b87ead0dedc70349272_1440w.jpg?source=c8b7c179" alt="XJTU主楼">  </p><p>4、$2019$年$7$月$24$日 北京中科院空间所实习(感觉像是去旅游)<br><img src="https://note.youdao.com/yws/api/personal/file/WEBdb1eecd6759a815f8c1f74f09dcf59be?method=download&shareKey=db01fa57b10b434ada861e14c93e6ff2" alt="北京郊外的晚上">  </p><p>5、$2020$年$11$月$16$日 晚上$22:40$的钱学森图书馆<br><img src="https://pic3.zhimg.com/v2-8a25f4a9b0f34d10f00d0ff359057ae4_r.jpg?source=c8b7c179" alt="图书馆24小时开放区">  </p><p>6、$2018$年$3$月$25$日 校园马拉松<br><img src="https://note.youdao.com/yws/api/personal/file/WEB90095b9151e05e45db79f99cf885975e?method=download&shareKey=db01fa57b10b434ada861e14c93e6ff2" alt="马拉松">  </p><p>7、创新港<br>$2019$年$9$月$13$日 中秋节第一次来创新港旅游，和同学住在豪华的宿舍里<br><img src="https://pic2.zhimg.com/80/v2-051d2f5162723e87186ad29be77105de_1440w.jpg?source=c8b7c179" alt="单人间宿舍"><br><img src="https://pica.zhimg.com/v2-0ddc2f5843e3a6fa49fe989c241e7d28_r.jpg?source=c8b7c179" alt="宿舍客厅（一个房间5-6个单人间）"><br>$2019$年$10$月$2$日 国庆期间又来创新港旅游<br>下图为涵英楼<br><img src="https://note.youdao.com/yws/api/personal/file/WEB4e0629322ae26b79af67b93dd5df1b0e?method=download&shareKey=db01fa57b10b434ada861e14c93e6ff2" alt="创新港主楼"><br>电信学部大楼和足球场<br><img src="https://note.youdao.com/yws/api/personal/file/WEB6006c969d052a4f4146abcedea406067?method=download&shareKey=db01fa57b10b434ada861e14c93e6ff2">  </p><p>8、兴庆校区<br>$2021$年$4$月$5$日 校园里的樱花，前两天刚考完复试<br><img src="https://note.youdao.com/yws/api/personal/file/WEB38194b137e581029cf901c94b3bdc814?method=download&shareKey=db01fa57b10b434ada861e14c93e6ff2" alt="樱花大道"><br><img src="https://note.youdao.com/yws/api/personal/file/WEB0fd95bd61ee6e070029b954418612526?method=download&shareKey=db01fa57b10b434ada861e14c93e6ff2"><br>$2017$年$10$月$19$日 上课路上顺手拍的梧桐树<br>![梧桐树]](<a href="https://note.youdao.com/yws/api/personal/file/WEB22226745fe65002feb7075aed5842dde?method=download&shareKey=db01fa57b10b434ada861e14c93e6ff2">https://note.youdao.com/yws/api/personal/file/WEB22226745fe65002feb7075aed5842dde?method=download&amp;shareKey=db01fa57b10b434ada861e14c93e6ff2</a>)<br>$2018$年$1$月$4$日 罕见的大雪<br><img src="https://pic2.zhimg.com/80/v2-034c4696526293347e4622f87f4b737b_1440w.jpg?source=c8b7c179" alt="校门口的雪人"><br><img src="https://pic1.zhimg.com/80/v2-861edb62b47ab52d60fb333e7dbded04_1440w.jpg?source=c8b7c179" alt="梅花">  </p><p>9、校园周边<br>$2018$年$3$月$2$日 元宵节 大唐芙蓉园<br><img src="https://note.youdao.com/yws/api/personal/file/WEB65908daf3cb1e2a1dd4ea365679dd30b?method=download&shareKey=db01fa57b10b434ada861e14c93e6ff2" alt="紫云阁"><br><img src="https://note.youdao.com/yws/api/personal/file/WEB74864dff2786bd09010ab882df6e4131?method=download&shareKey=db01fa57b10b434ada861e14c93e6ff2"><br><img src="https://note.youdao.com/yws/api/personal/file/WEB0931f7b33ccb31727e56320d3c9b27d8?method=download&shareKey=db01fa57b10b434ada861e14c93e6ff2" alt="湖"><br>这个是大唐不夜城<br><img src="https://note.youdao.com/yws/api/personal/file/WEB71e65d8535c8446713b47bd28a86c4c5?method=download&shareKey=db01fa57b10b434ada861e14c93e6ff2" alt="大唐不夜城街景"><br>以此纪念我逝去的大学生活，我逝去的青春！</p>]]></content>
      
      
      <categories>
          
          <category> 生活篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
